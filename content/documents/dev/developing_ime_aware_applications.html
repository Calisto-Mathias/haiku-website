+++
type = "article"
title = "Developing IME Aware Applications"
date = "2006-12-10T20:13:00.000Z"
tags = ["input method aware"]
+++


<p>To support Haiku and do something useful for it, I am pleased to show you how to communicate with the input server in BeOS.</p>

<p>In BeOS, almost everything uses the UTF-8 character encoding for the processing of characters. Thus, if you want to write or display the characters of other languages than English, all you need to do is to find a font able to display the characters properly and an input method add-on to help you at outputting characters to the running application. The input method handling of BeOS was originally found in <a href="https://web.archive.org/web/19990224083358/http://www.be.com/aboutbe/pressreleases/98-05-28_be_ergosoft.html" target="_blank">the Japanese support</a>. It works this way: The input server loads the add-ons located at <span class="geshifilter"><code class="cpp geshifilter-cpp">B_SYSTEM_ADDONS_DIRECTORY</code></span> /input_server/methods or <span class="geshifilter"><code class="cpp geshifilter-cpp">B_USER_ADDONS_DIRECTORY</code></span>/input_server/methods, then filter all events generated by the keyboard or mouse with the Filter() method of BInputServerFilter to change them. There are only a few input methods written since the time BeOS R4 was released. Maybe it's because   only ERGOSOFT Crop. and just a few developers know how to have method working. In my memory, existing methods are BeCJK, HanBe, Canna, ChineseTool and more recently "Anthy for Zeta".</p>


<!--more-->


<p>Maybe you don't care about the development of an input method, but you probably need to know a bit when implementing BView-derived classes. Your own class needs to deal with internationalized text, such as a word editor or a web page etc. Although the BTextView class would do most of the work for you, BTextView is a huge class, sometime you need to write a custom and flexible class for other purposes.</p>

<p>We'll explain that in two parts. Part 1 will show you how to write an input aware application, then we'll see how to write an input method at part 2.</p>

<h2>Part 1: Input method aware derived class from BView</h2>

<p>The tutorial is based on a class I wrote a long time ago, the contents of its header file is shown below:</p>

<pre>
<font color="#a020f0">#ifndef __SINPUT_AWARE_STRING_VIEW_H__</font>
<font color="#a020f0">#define __SINPUT_AWARE_STRING_VIEW_H__</font>

<font color="#a020f0">#include </font><font color="#ff00ff">&lt;SupportDefs.h&gt;</font>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;Messenger.h&gt;</font>
<font color="#a020f0">#include </font><font color="#ff00ff">&lt;Input.h&gt;</font>

<font color="#a020f0">#include </font><font color="#ff00ff">&lt;besavager/StringView.h&gt;</font>


<font color="#2e8b57"><b>class</b></font> SInputAwareStringView : <font color="#a52a2a"><b>public</b></font> SStringView {
<font color="#a52a2a"><b>public</b></font>:
        SInputAwareStringView(BRect frame, <font color="#2e8b57"><b>const</b></font> <font color="#2e8b57"><b>char</b></font> *name,
                              <font color="#2e8b57"><b>uint32</b></font> resizeMask = B_FOLLOW_LEFT | B_FOLLOW_TOP,
                              <font color="#2e8b57"><b>uint32</b></font> flags = B_WILL_DRAW | B_FRAME_EVENTS);

        <font color="#2e8b57"><b>virtual</b></font> <font color="#2e8b57"><b>void</b></font> MessageReceived(BMessage *message);

<font color="#a52a2a"><b>private</b></font>:
        BMessenger msgr_input;
        <font color="#2e8b57"><b>bool</b></font> im_started;

        <font color="#2e8b57"><b>void</b></font> IMStarted(BMessage *message);
        <font color="#2e8b57"><b>void</b></font> IMStopped();
        <font color="#2e8b57"><b>void</b></font> IMChanged(BMessage *message);
        <font color="#2e8b57"><b>void</b></font> IMLocationRequest(BMessage *message);
};

<font color="#a020f0">#endif</font> <font color="#0000ff">/*</font><font color="#0000ff"> __SINPUT_AWARE_STRING_VIEW_H__ </font><font color="#0000ff">*/</font>
</pre>

<h3>Section 1.1 The B_INPUT_METHOD_AWARE flag</h3>

<p>If BView's flags contains B_INPUT_METHOD_AWARE, it means the B_INPUT_METHOD_EVENT message generated by the active input method will be processed by the MessageReceived() method, otherwise the input server will popup a window to deal with the message then send a message (B_KEY_DOWN) to the application later (This can cause strange issues in newer versions of BeOS, like Dano/Zeta etc.).</p>

<p>So, the derived class should do something like below in its constructor:</p>

<pre>
SInputAwareStringView::SInputAwareStringView(BRect frame, <font color="#2e8b57"><b>const</b></font> <font color="#2e8b57"><b>char</b></font> *name, <font color="#2e8b57"><b>uint32</b></font> resizeMask, <font color="#2e8b57"><b>uint32</b></font> flags)
        : SStringView(frame, name, <font color="#ff00ff">NULL</font>, <font color="#ff00ff">NULL</font>, <font color="#ff00ff">0</font>, <font color="#ff00ff">NULL</font>, resizeMask, flags | B_INPUT_METHOD_AWARE), im_started(<font color="#ff00ff">false</font>)
{
}
</pre>

<h3>Section 1.2 The B_KEY_DOWN message</h3>

<p>The B_KEY_DOWN message is the most important keyboard event. The input server sends this message to the active view of the running application when its flags don't contain B_INPUT_METHOD_AWARE.</p>

<p>The message contains the fields shown below (from the Be Book):</p>

<table class="list" border="1" align="middle" cellpadding="2" cellspacing="0"><tbody class="list">
	<tr class="item_title"><td>Field</td><td>Type code</td><td>Description</td></tr>
	<tr><td>"when"</td><td>B_INT64_TYPE</td><td>Event time, in microseconds since 01/01/70</td></tr>
	<tr><td>"key"</td><td>B_INT32_TYPE</td><td>The code for the physical key that was pressed, you can find out how to get the key by the functions by "key" shown below</td></tr>
	<tr><td>"be:key_repeat"</td><td>B_INT32_TYPE</td><td>The "iteration number" of this key down.</td></tr>
	<tr><td>"modifiers"</td><td>B_INT32_TYPE</td><td>The modifier keys that were in effect at the time of the event.</td></tr>
	<tr><td>"states"</td><td>B_UINT8_TYPE</td><td>The state of all keys at the time of the event.</td></tr>
	<tr><td>"byte"[3]</td><td>B_INT8_TYPE</td><td>The UTF-8 data that's generated, it contains three bytes.</td></tr>
	<tr><td>"bytes"</td><td>B_STRING_TYPE</td><td>The UTF-8 string that's generated. (The string usually contains a single character, and usually contains words when it was sent by input server as the B_INPUT_METHOD_EVENT handled.)</td></tr>
	<tr><td>"raw_char"</td><td>B_INT32_TYPE</td><td>Modifier-independent ASCII code for the character.</td></tr>
</tbody></table>

<p>A perfect derived class should pay attention to the contents of the field named "bytes", then the field named "byte"[3] if "bytes" doesn't exist, then lastly "raw_char".</p>

<h3>Section 1.3 The B_INPUT_METHOD_EVENT message</h3>

<p>The input server sends this message to the view when the input method did some work. The message will be ignored if the view's flags doesn't contain B_INPUT_METHOD_AWARE. The paragraphs shown below are quoted from the Be Book.</p>

<p>Each B_INPUT_METHOD_EVENT message contains a be:opcode field (an int32 value) indicating the kind of event:</p>

<table class="list" border="1" align="middle" cellpadding="2" cellspacing="0"><tbody class="list">
	<tr class="item_title"><td>Value</td><td>Description</td></tr>
	<tr><td>B_INPUT_METHOD_STARTED</td><td>Indicates that a new input transaction has begun.</td></tr>
	<tr><td>B_INPUT_METHOD_STOPPED</td><td>Indicates that the transaction is over.</td></tr>
	<tr><td>B_INPUT_METHOD_CHANGED</td><td>Indicates that the state of transaction is changed.</td></tr>
	<tr><td>B_INPUT_METHOD_LOCATION_REQUEST</td><td>Indicates that the input method asking for the on-screen location of each character.</td></tr>
</tbody></table>

<p>In addition, except B_INPUT_METHOD_STOPPED, the special fields contained in each other kind.

<p>The B_INPUT_METHOD_STARTED contains fields shown below:

<table class="list" border="1" align="middle" cellpadding="2" cellspacing="0"><tbody class="list">
	<tr class="item_title"><td>Field</td><td>Type code</td><td>Description</td></tr>
	<tr><td>"be:reply_to"</td><td>B_MESSENGER_TYPE</td><td>The messenger to communicate with you during the transaction</td></tr>
</tbody></table>

<p>The messenger pointed by "be:reply_to" usually for replying the location of characters to input method, you can also use it to send a B_INPUT_METHOD_STOPPED kind message or others to stop the transaction.</p>

<p>The B_INPUT_METHOD_CHANGED contains fields shown below:</p>

<table class="list" border="1" align="middle" cellpadding="2" cellspacing="0"><tbody class="list">
	<tr class="item_title"><td>Field</td><td>Type code</td><td>Description</td></tr>
	<tr><td>"be:string"</td><td>B_STRING_TYPE</td><td>The text the user is currently entering; the receiver will display it at the current insertion point. BTextView also highlights the text in blue to show that it's part of a transitory transaction.</td></tr>
	<tr><td>"be:selection"</td><td>B_INT32_TYPE</td><td>A pair of B_INT32_TYPE offsets in bytes into the be:string if part of be:string is current selected. BTextView highlights this selection in red instead of drawing it in blue.</td></tr>
	<tr><td>"be:clause_start"</td><td>B_INT32_TYPE</td><td>Zero or more offsets into the be:string for handling languages (such as Japanese) that separate a sentence or phrase into numerous clauses. An equal number of be:clause_start and be:clause_end pairs delimit these clauses; BTextView separates the blue/red highlighting wherever there is a clause boundary.</td></tr>
	<tr><td>"be:clause_end"</td><td>B_INT32_TYPE</td><td>Zero or more offsets into be:string; there must be as many be:clause_end entries as there are be:clause_start.</td></tr>
	<tr><td>"be:confirmed"</td><td>B_BOOL_TYPE</td><td>True when the user has entered and "confirmed" the current string and wishes to end the transaction. BTextView unhighlights the blue/red text and waits for a B_INPUT_METHOD_STOPPED (to close the transaction) or another B_INPUT_METHOD_CHANGED (to start a new transaction immediately).</td></tr>
</tbody></table>


<p>When the kind of B_INPUT_METHOD_EVENT is B_INPUT_METHOD_LOCATION_REQUEST, the derived class should reply the message contains the fields shown below to the messenger that pointed by "be:reply_to" in the B_INPUT_METHOD_STARTED kind:</p>

<table class="list" border="1" align="middle" cellpadding="2" cellspacing="0"><tbody class="list">
	<tr class="item_title"><td>Field</td><td>Type code</td><td>Description</td></tr>
	<tr><td>"be:opcode"</td><td>B_INT32_TYPE</td><td>Must set to B_INPUT_METHOD_LOCATION_REQUEST.</td></tr>
	<tr><td>"be:location_reply"</td><td>B_POINT_TYPE</td><td>The coordinates of each UTF-8 character (there should be one be:location_reply for every character in be:string, and the character maybe contains more than one byte) relative to the display (not your view or your window).</td></tr>
	<tr><td>"be:height_reply"</td><td>B_FLOAT_TYPE</td><td>The height of each character(maybe contains more than on byte) in be:string.</td></tr>
</tbody></table>

<h3>Section 1.4 Example</h3>

<p>Now, we will start our practice if you are ready for coding.</p>

<pre>
<font color="#2e8b57"><b>void</b></font>
SInputAwareStringView::MessageReceived(BMessage *message)
{
        <font color="#a52a2a"><b>switch</b></font>(message-&gt;what)
        {
                <font color="#a52a2a"><b>case</b></font> B_INPUT_METHOD_EVENT: <font color="#0000ff">// input method event received</font>
                        {
                                <font color="#2e8b57"><b>int32</b></font> op_code; <font color="#0000ff">// the kind of message</font>
                                <font color="#a52a2a"><b>if</b></font>(message-&gt;FindInt32(<font color="#ff00ff">&quot;be:opcode&quot;</font>, &amp;op_code) != B_OK) <font color="#a52a2a"><b>break</b></font>;

                                <font color="#a52a2a"><b>switch</b></font>(op_code)
                                {
                                        <font color="#a52a2a"><b>case</b></font> B_INPUT_METHOD_STARTED: <font color="#0000ff">// prepare for input transaction</font>
                                                IMStarted(message);
                                                <font color="#a52a2a"><b>break</b></font>;

                                        <font color="#a52a2a"><b>case</b></font> B_INPUT_METHOD_STOPPED: <font color="#0000ff">// stop the transaction and clear something</font>
                                                IMStopped();
                                                <font color="#a52a2a"><b>break</b></font>;

                                        <font color="#a52a2a"><b>case</b></font> B_INPUT_METHOD_CHANGED: <font color="#0000ff">// displaying characters when the string entering changed</font>
                                                IMChanged(message);
                                                <font color="#a52a2a"><b>break</b></font>;

                                        <font color="#a52a2a"><b>case</b></font> B_INPUT_METHOD_LOCATION_REQUEST: <font color="#0000ff">// reply the lcoation of characters</font>
                                                IMLocationRequest(message);
                                                <font color="#a52a2a"><b>break</b></font>;

                                        <font color="#a52a2a"><b>default</b></font>: <font color="#0000ff">// call member function of base class</font>
                                                SStringView::MessageReceived(message);
                                }
                        }
                        <font color="#a52a2a"><b>break</b></font>;

                <font color="#a52a2a"><b>default</b></font>: <font color="#0000ff">// call member function of base class</font>
                        SStringView::MessageReceived(message);
        }
}


<font color="#2e8b57"><b>void</b></font>
SInputAwareStringView::IMStarted(BMessage *message)
{
        <font color="#0000ff">// here we store the messenger that we would communicate with the input method during the transaction</font>
        im_started = (message-&gt;FindMessenger(<font color="#ff00ff">&quot;be:reply_to&quot;</font>, &amp;msgr_input) == B_OK);
}


<font color="#2e8b57"><b>void</b></font>
SInputAwareStringView::IMStopped()
{
        msgr_input = BMessenger();
        SetText(<font color="#ff00ff">NULL</font>); <font color="#0000ff">// clear the text had shown</font>
        im_started = <font color="#ff00ff">false</font>;
}


<font color="#2e8b57"><b>void</b></font>
SInputAwareStringView::IMChanged(BMessage *message)
{
        <font color="#a52a2a"><b>if</b></font>(!im_started) <font color="#a52a2a"><b>return</b></font>;

        <font color="#2e8b57"><b>const</b></font> <font color="#2e8b57"><b>char</b></font> *im_string = <font color="#ff00ff">NULL</font>;
        message-&gt;FindString(<font color="#ff00ff">&quot;be:string&quot;</font>, &amp;im_string);
        <font color="#a52a2a"><b>if</b></font>(im_string == <font color="#ff00ff">NULL</font>) im_string = <font color="#ff00ff">&quot;&quot;</font>;

        <font color="#2e8b57"><b>int32</b></font> start = <font color="#ff00ff">0</font>, end = <font color="#ff00ff">0</font>;

        BList color_list;

        <font color="#a52a2a"><b>for</b></font>(<font color="#2e8b57"><b>int32</b></font> i = <font color="#ff00ff">0</font>;
                message-&gt;FindInt32(<font color="#ff00ff">&quot;be:clause_start&quot;</font>, i, &amp;start) == B_OK &amp;&amp;
                message-&gt;FindInt32(<font color="#ff00ff">&quot;be:clause_end&quot;</font>, i, &amp;end) == B_OK; i++)
        {
                <font color="#0000ff">// handle clauses</font>
                <font color="#a52a2a"><b>if</b></font>(end &gt; start) <font color="#0000ff">// visible</font>
                {
                        <font color="#0000ff">// set the background of clauses to be blue, the offsets are in bytes.</font>
                        <font color="#0000ff">// for example, the "[/]" means the start/end offset of that.</font>
                        <font color="#0000ff">// string: T h i s i s a [w o r d] .</font>
                        <font color="#0000ff">// offset: 0 1 2 3 4 5 6 7  8 9 10 11</font>
                        <font color="#0000ff">// &quot;be:clause_start&quot; = 7</font>
                        <font color="#0000ff">// &quot;be:clause_end&quot; = 11</font>
                        s_string_view_color *color = <font color="#a52a2a"><b>new</b></font> s_string_view_color;
                        s_rgb_color_setto(&amp;color-&gt;color, <font color="#ff00ff">0</font>, <font color="#ff00ff">0</font>, <font color="#ff00ff">0</font>);
                        s_rgb_color_setto(&amp;color-&gt;background, <font color="#ff00ff">152</font>, <font color="#ff00ff">203</font>, <font color="#ff00ff">255</font>);
                        color-&gt;draw_background = <font color="#ff00ff">true</font>;
                        color-&gt;start_offset = start;
                        color-&gt;end_offset = end - <font color="#ff00ff">1</font>;
                        color_list.AddItem((<font color="#2e8b57"><b>void</b></font>*)color);
                }
        }

        <font color="#a52a2a"><b>for</b></font>(<font color="#2e8b57"><b>int32</b></font> i = <font color="#ff00ff">0</font>;
                message-&gt;FindInt32(<font color="#ff00ff">&quot;be:selection&quot;</font>, i * <font color="#ff00ff">2</font>, &amp;start) == B_OK &amp;&amp;
                message-&gt;FindInt32(<font color="#ff00ff">&quot;be:selection&quot;</font>, i * <font color="#ff00ff">2</font> + <font color="#ff00ff">1</font>, &amp;end) == B_OK; i++)
        {
                <font color="#0000ff">// handle selection</font>
                <font color="#a52a2a"><b>if</b></font>(end &gt; start) <font color="#0000ff">// visible</font>
                {
                        <font color="#0000ff">// set the background of clauses to be red, the offsets are in bytes.</font>
                        <font color="#0000ff">// for example, the "[/]" means the start/end offset of that.</font>
                        <font color="#0000ff">// string: T h i s i s a [w o r d] .</font>
                        <font color="#0000ff">// offset: 0 1 2 3 4 5 6 7  8 9 10 11</font>
                        <font color="#0000ff">// &quot;be:selection&quot;[0] = 7</font>
                        <font color="#0000ff">// &quot;be:selection&quot;[1] = 11</font>
                        s_string_view_color *color = <font color="#a52a2a"><b>new</b></font> s_string_view_color;
                        s_rgb_color_setto(&amp;color-&gt;color, <font color="#ff00ff">0</font>, <font color="#ff00ff">0</font>, <font color="#ff00ff">0</font>);
                        s_rgb_color_setto(&amp;color-&gt;background, <font color="#ff00ff">255</font>, <font color="#ff00ff">152</font>, <font color="#ff00ff">152</font>);
                        color-&gt;draw_background = <font color="#ff00ff">true</font>;
                        color-&gt;start_offset = start;
                        color-&gt;end_offset = end - <font color="#ff00ff">1</font>;
                        color_list.AddItem((<font color="#2e8b57"><b>void</b></font>*)color);
                }
        }

        <font color="#a52a2a"><b>if</b></font>(!color_list.IsEmpty()) <font color="#0000ff">// you don't need to know what it is below</font>
        {
                <font color="#2e8b57"><b>int32</b></font> n = color_list.CountItems();
                s_string_view_color *colors = <font color="#a52a2a"><b>new</b></font> s_string_view_color[n];

                <font color="#a52a2a"><b>for</b></font>(<font color="#2e8b57"><b>int32</b></font> i = <font color="#ff00ff">0</font>; i &lt; n; i++)
                {
                        s_string_view_color *color = (s_string_view_color*)color_list.ItemAt(i);
                        <font color="#a52a2a"><b>if</b></font>(color)
                        {
                                <font color="#a52a2a"><b>if</b></font>(colors)
                                {
                                        s_rgb_color_setto(&amp;colors[i].color, color-&gt;color);
                                        s_rgb_color_setto(&amp;colors[i].background, color-&gt;background);
                                        colors[i].draw_background = color-&gt;draw_background;
                                        colors[i].start_offset = color-&gt;start_offset;
                                        colors[i].end_offset = color-&gt;end_offset;
                                }

                                <font color="#a52a2a"><b>delete</b></font> color;
                        }
                }

                color_list.MakeEmpty();

                SetText(im_string, colors, n);
                <font color="#a52a2a"><b>if</b></font>(colors) <font color="#a52a2a"><b>delete</b></font>[] colors;
        }
        <font color="#a52a2a"><b>else</b></font>
        {
                SetText(im_string);
        }
}


<font color="#2e8b57"><b>void</b></font>
SInputAwareStringView::IMLocationRequest(BMessage *message)
{
        <font color="#a52a2a"><b>if</b></font>(!im_started) <font color="#a52a2a"><b>return</b></font>;

        <font color="#2e8b57"><b>const</b></font> <font color="#2e8b57"><b>char</b></font> *im_string = Text();
        <font color="#a52a2a"><b>if</b></font>(im_string == <font color="#ff00ff">NULL</font> || *im_string == <font color="#ff00ff">0</font>) <font color="#a52a2a"><b>return</b></font>;

        BMessage reply(B_INPUT_METHOD_EVENT); <font color="#0000ff">// the message for reply</font>
        reply.AddInt32(<font color="#ff00ff">&quot;be:opcode&quot;</font>, B_INPUT_METHOD_LOCATION_REQUEST); <font color="#0000ff">// must set this</font>

        BPoint left_top = ConvertToScreen(BPoint(<font color="#ff00ff">0</font>, <font color="#ff00ff">0</font>)); <font color="#0000ff">// first we convert the (0, 0) to the coordinate relative to the display</font>

        <font color="#2e8b57"><b>int32</b></font> offset = <font color="#ff00ff">0</font>;
        <font color="#2e8b57"><b>uint32</b></font> index = <font color="#ff00ff">0</font>;

        <font color="#a52a2a"><b>while</b></font>(<font color="#ff00ff">true</font>)
        {
                <font color="#a52a2a"><b>if</b></font>(__utf8_char_at(im_string, index, &amp;offset)) <font color="#0000ff">// the (index + 1)th UTF-8 character</font>
                {
                        BRect rect = TextRegion(offset, offset + <font color="#ff00ff">1</font>).Frame(); <font color="#0000ff">// get the region of text relative to the view</font>
                        <font color="#a52a2a"><b>if</b></font>(!rect.IsValid()) <font color="#a52a2a"><b>break</b></font>;

                        <font color="#0000ff">// convert to the coordinate relative to the display</font>
                        BPoint pt = left_top;
                        pt += rect.LeftTop();

                        reply.AddPoint(<font color="#ff00ff">&quot;be:location_reply&quot;</font>, pt); <font color="#0000ff">// the left-top point of each character</font>
                        reply.AddFloat(<font color="#ff00ff">&quot;be:height_reply&quot;</font>, rect.Height()); <font color="#0000ff">// the height of each character</font>
                }
                <font color="#a52a2a"><b>else</b></font>
                {
                        <font color="#a52a2a"><b>break</b></font>;
                }

                index++;
        }

        <font color="#0000ff">// send the message to the input method within input server</font>
        msgr_input.SendMessage(&amp;reply);
}
</pre>
