
               <html>
                    <!-- Heading -->
                    <head>
                         <title>OpenBeOS Project - Displaying Newsletter</title>
                         <meta name="Keywords" content="OpenBeOS, BeOS, OBOS, operating system, developer">
                         <meta http-equiv="Cache-Control" content="no-cache">
                         <meta http-equiv="Pragma" content="no-cache">
                    </head>
                    <!-- / Heading -->
                    <!-- Body -->
                    <body bgcolor="#ffffff" leftmargin=5 topmargin=5>

                         <!-- Top Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0 bgcolor="#a7afbb">

                              <!-- Logo -->
                              <tr valign="bottom"><td><img src="images/logo.png" border=0></td></tr>
                              <!-- / Logo -->

                              <!-- Slogan -->
                              <tr valign="top">
                                   <td width="100%">
                                        <img src="images/spacer.gif" height=1 width=160><img src="images/slogan.png">
                                   </td>
                              </tr>
                              <!-- / Slogan -->

                              <tr><td colspan=2><img src="images/spacer.gif" height=6 width=1></td></tr>
                         
                         </table>
                         <!-- / Top Table -->
                         
                         <!-- Main Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0>
                              <tr valign="top">
                              
                                                  

                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>
                                   <td width=16 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=15>&nbsp;</td>
                                   
                                   <!-- Content -->
                                   <td width="100%">
                                        <font size="-1" face="Verdana, Arial">
                                        
     	    	<table width="99%" cellspacing=0 cellpadding=0 border=0>
           	     <tr>
                	     <td height="12"><a name="top">&nbsp;</a><img src="images/spacer.gif" heigh="12" width=1></td>
               	</tr>
               	<tr>
                         <td>
                    	     <img src="images/N.png" align="absmiddle" border=0>
                              <img src="images/spacer.gif" height=1 width=20>
                              <font face="Verdana, Arial" size="+2" color="#331111">Displaying Newsletter<div align="right"><font size="-1"><a href="index.html">Newsletter Archive</a></font></div></font>
                              <img src="images/spacer.gif" heigh=20 width=1>
                         </td>
               	</tr>
               	<font size="-1" face="Verdana, Arial">
               	
               <tr>
                    <td><font color="#113355" face="Verdana,Arial"><b>Issue 41, 30 Apr 2003</b></font>
                         
                    </td>
               </tr>
               <tr><td height="6"><img src="images/spacer.gif" height="6"></td></tr>
               <!-- Newsletter Header Links -->
               <tr>
                    <td bgcolor=#eeeeee>
                    
                         <table width="100%" cellspacing="2" cellpadding="0" border="0">
                              <tr valign="top">
                                   <td bgcolor="#f6f6f6">
                                        <font face="verdana,arial" size="-1">
                                        <br><br>&nbsp;&nbsp;<b><font color="">In This Issue:</font></b>
                                        <ul type="square">
                                             <li><a href="#146">The Art of Jamming, Part 2</a>&nbsp; by Ryan Leavengood</li><li><a href="#147">Family Fun</a>&nbsp; by Michael Phipps</li>
                                        </ul>
                                        </font>
                                   </td>
                              </tr>
                         </table>
               
                    </td>
               </tr>
               <!-- / Newsletter Header Links -->
               
		     <!-- Newsletter Article (ID:146) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="146">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">The Art of Jamming, Part 2</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:leavengood@users.sf.net">Ryan Leavengood</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>
The <a href="nsl37.html#134">last article</a>
in this series introduced the Jam build tool from a high-level
and described the Jamfile-engine that has been created to replace the Be
makefile-engine. This second of three articles will show how the Jamfile-engine
is implemented, and while doing so will provide more advanced information
about Jam.
<p>
At this point it should be mentioned that any readers who have not already downloaded the
Jamfile-engine may want to before continuing:
<a href="samples/Jamfile-engine.zip">Jamfile-engine.zip</a>.
If you downloaded this previously, you may want to get the latest version, in
which more comments have been added and some bug fixes made as well.
<p>
If you open up the Jamfile-engine text file, you will notice it begins with a
fairly standard comment section at the beginning:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600>##  OpenBeOS Generic Jamfile Engine v1.0.1</font>
<font color=#006600>##  Does all the hard work for the Generic Jamfile</font>
<font color=#006600>##  which simply defines the project parameters.</font>
<font color=#006600>##  Most of the real work is done in the Jambase</font>
<font color=#006600>##  embedded into the jam executable.</font>
<font color=#006600>##</font>
<font color=#006600>##  Inspired by the Be Makefile Engine</font>
<font color=#006600>##</font>
<font color=#006600>##  Supports Generic Jamfile v1.0</font>
<font color=#006600>##</font>
<font color=#006600>##  Copyright (c) 2002, 2003 Ryan Leavengood</font>
<font color=#006600>##  Released under the Terms of the MIT License, see</font>
<font color=#006600>##  http://www.opensource.org/licenses/mit-license.html</font>
</pre></td></tr></table>
<p>
<br>
From this you will realize that comments in Jam begin with a hash symbol
(<code><font size=+1>#</font></code>) and they continue until the end of the line. In this case two
hashes are used to make this comment stand out more and to indicate that it
describes the file as a whole and not just some implementation detail.
<p>
After the initial comment the real code begins. In the first part of the
Jamfile-engine, several utility rules are defined that can be used and re-used
later in the file. The first few rules are simple:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># AddResources &lt;Application Name&gt; : &lt;Resource Files&gt; ;</font>
<font color=#006600>#   Adds the given resources to the given application.</font>

rule AddResources
{
    Depends $(&lt;) : $(&gt;) ;
}

actions AddResources
{
    $(XRES) -o "$(&lt;)" $(&gt;)
}

<font color=#006600># MimeSet &lt;Application Name&gt;;</font>
<font color=#006600>#   Sets the mime type of the given application to be an application.</font>
actions MimeSet
{
    $(MIMESET) -f "$(&lt;)"
}
</font></pre></td></tr></table>

<p>
<br>
<h4>Jam Rules: Procedure and Actions</h4>
After looking at the template above, many readers may be confused. Why is AddResources
defined twice, once using the word <font face="Courier New, Courier10 BT" size=3>rule</font> and then with the word <font face="Courier New, Courier10 BT" size=3>actions</font>?
The reason is that Jam rules are created in two parts:
<ol>
	<li><em>The procedure</em> (defined using the keyword <font face="Courier New, Courier10 BT" size=3>rule</font>):<br>
	A set of Jam language statements that are run when the rule is invoked and which
	usually set up variables that will be used in the actions.
	<br><br>
	<li><em>The actions</em>:<br>
	Shell commands that get run when a target needs updating
	(and make use of the variables configured in the procedure.)
</ol>

<p>
In the above case of AddResources, the procedure sets up a dependency between
the first parameter and the second parameter:
<br><br>
&nbsp; &nbsp; &nbsp; &nbsp;<font face="Courier New, Courier10 BT" size=3>$(&lt;)</font>
 depends on <font face="Courier New, Courier10 BT" size=3>$(&gt;)</font>
<br><br>
meaning that when <font face="Courier New, Courier10 BT" size=3>$(&gt;)</font> changes, <font face="Courier New, Courier10 BT" size=3>$(&lt;)</font> must be updated.
<p>
<br>
<h4>Rule Parameters</h4>
The variables used here, <font face="Courier New, Courier10 BT" size=3>$(&lt;)</font> and <font face="Courier New, Courier10 BT" size=3>$(&gt;)</font>
are aliases for <font face="Courier New, Courier10 BT" size=3>$(1)</font> and <font face="Courier New, Courier10 BT" size=3>$(2)</font>, which are the first and second parameters passed
to the rule, respectively. Up to 9 parameters, <font face="Courier New, Courier10 BT" size=3>$(1) - $(9)</font>, may be passed to
rules. While all can be used in the procedure, only the first two can be used in the actions.
<p>
In the case of the actions for AddResources, the command
xres is called using the variable <font face="Courier New, Courier10 BT" size=3>$(XRES)</font>, with the output <font face="Courier New, Courier10 BT" size=3>(-o)</font> being the
quoted value of <font face="Courier New, Courier10 BT" size=3>$(&lt;)</font> (the quotes allow for spaces in the application name),
and with the input resource files being the value of <font face="Courier New, Courier10 BT" size=3>$(&gt;)</font>.
<p>
When defining updating rules, <font face="Courier New, Courier10 BT" size=3>$(1)</font> or <font face="Courier New, Courier10 BT" size=3>$(&lt;)</font> is generally considered
to be the target (what will be created by the rule) and <font face="Courier New, Courier10 BT" size=3>$(2)</font> or <font face="Courier New, Courier10 BT" size=3>$(&gt;)</font>
is the source(s) (what the target will be created from.)
<p>
Though mentioned briefly, it should be evident
that <font face="Courier New, Courier10 BT" size=3>$(XRES)</font> is just a reference to a global variable defined elsewhere in the
Jamfile-engine (which just has the name of the xres command.) This shows that
any variables within scope can be used in the actions for a rule.
<p>
After AddResources, the MimeSet rule is created, but in this case there is no
procedure because there are no variables needed or dependencies for this rule.
In fact, this rule only has one parameter: the name of the application that the
mimeset command should be run against.
<p>
After the above rules a more complicated rule is defined:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># ProcessLibs &lt;List of Library Names&gt; ;</font>
<font color=#006600>#   Prepends -l to any library names that aren&#039t _APP_ or _KERNEL_ or</font>
<font color=#006600>#   that don&#039t have .a or .so file extensions.  The result will be given</font>
<font color=#006600>#   to the linker so that it links to the right libraries.</font>
rule ProcessLibs
{
    local result ;
    
    for i in $(1)
    {
        if ( ( $(i) in _APP_ _KERNEL_ ) || ( $(i:S) in .so .a ) )
        {
            result += $(i) ;
        }
        else
        {
            result += -l$(i) ;
        }
    }
    
    return $(result) ;
}
</pre></td></tr></table>
<p>
<br>
There is a lot going on in the rule, but the first thing that should be
mentioned is that, in contrast to the MimeSet rule, this rule only has a
procedure but no associated actions. In this case the rule is just a string
processing rule that iterates over a list of library names and adds a -l prefix
to those that aren&#039t _APP_ or _KERNEL_ or that don&#039t end in .so or
.a. To implement this functionality, a lot of the built-in Jam language is used.
<p>
<br>
<h4>Basic Syntax</h4>
The first thing done in this rule is the declaration a local variable called
<font face="Courier New, Courier10 BT" size=3>result</font>. The <font face="Courier New, Courier10 BT" size=3>local</font> keyword provides for dynamic scoping (as in C or
C++): if another variable named <font face="Courier New, Courier10 BT" size=3>result</font> exists when this rule is called, that
old value will be saved, the new value will have nothing to do with the old one,
and then after the rule is finished, the new value is discarded and the old one restored.
<p>
After the declaration of the local result variable, there is another new piece
of syntax: the for loop. In this case the <font face="Courier New, Courier10 BT" size=3>for</font> keyword is used to
iterate over the items in the list <font face="Courier New, Courier10 BT" size=3>$(1)</font> (the first and only parameter to this
rule), setting the variable <font face="Courier New, Courier10 BT" size=3>i</font> to each item in turn.
<p>
After the for loop statement is its associated block, which contains the statements
that should be run on each loop iteration. This block contains a single
<font face="Courier New, Courier10 BT" size=3>if..else</font> statement, which is very similar to the if..else construct in C.
The condition that this if statement checks is fairly complex, but when broken
down it is simple: in the first set of parenthesis, the <font face="Courier New, Courier10 BT" size=3>in</font> keyword
is used to see if the current value of <font face="Courier New, Courier10 BT" size=3>$(i)</font> is in the list [_APP_ _KERNEL_].
<p>
<br>
<h4>List Handling</h4>
The <font face="Courier New, Courier10 BT" size=3>in</font> keyword, as can probably be guessed, returns true if the
first parameter is a subset of the second. Note the use of the term subset:
both "parameters" to the keyword <font face="Courier New, Courier10 BT" size=3>in</font> are lists, and the
result is only true if every element in the first list is in the second list.
(In this case only a single-element list is used for the first parameter.)
<p>
Also note that literal lists in the Jam language
(such as <font face="Courier New, Courier10 BT" size=3>_APP__KERNEL_</font> in this case)
do not need any delimiters (where C syntax would require curly brackets ({ and }),
commas (,), and double quotes (") to create a list of strings.)
This is one of the advantages of the syntax of Jam (and one of the reasons for all the whitespace.)
This really begins to illustrate that at its heart Jam is just a list processing language
(hello LISP fans!) In fact, changing the Jam syntax to be like LISP probably wouldn&#039t be too hard,
but that shall be left as an exercise for the reader.
<p>
<p>
<br>
<h4>Operators</h4>
After the first condition in the if is an or (<font face="Courier New, Courier10 BT" size=3>||</font>) disjunction,
which works just like the C equivalent (the result is only false if both sides
are false.) The second side of the or is a condition similar to the first: it
checks to see if something is in a list. In this case, though, one of Jam&#039s
variable modifiers, <font face="Courier New, Courier10 BT" size=3>:S</font>, is used.
<p>
What <font face="Courier New, Courier10 BT" size=3>:S</font> does is return the last filename suffix of the given variable --
in other words -- the file name extension. If the file name extension is in the list
".so.a", then this statement will be true.
<p>
Whenever the if condition (which you will note has whitespace
separating all tokens) returns true, the <font face="Courier New, Courier10 BT" size=3>+=</font> expression is used to
add the unmodified value of <font face="Courier New, Courier10 BT" size=3>$(i)</font> to the result list. The operator <font face="Courier New, Courier10 BT" size=3>+=</font>
works the same as in C: the value of result is set to the old value of result
plus the value of <font face="Courier New, Courier10 BT" size=3>$(i)</font>.  But since Jam is a list-oriented language, this
addition is not mathematical, but is a list addition: the new value is added as a
new element to the end of the list. In fact, Jam does not have any syntax for
doing math at all.
<p>
In the case that the if condition is false, the block under the else clause
will be run. This block adds the value of <font face="Courier New, Courier10 BT" size=3>$(i)</font> with the prefix <font face="Courier New, Courier10 BT" size=3>-l</font>
to the result list.
<p>
<h4>Variable Expansion</h4>
Though it doesn&#039t really come into play here, now is a good time to
mention how Jam "variable expansion" works. When you concatenate
several variables or a variable with one or more literals, the result is a list
that is a <i>product</i> of the components of the variables being combined.
<p>
For example, in the simple case of the <font face="Courier New, Courier10 BT" size=3>-l$(i)</font> statement above, the result will be
the value of <font face="Courier New, Courier10 BT" size=3>$(i)</font> with <font face="Courier New, Courier10 BT" size=3>-l</font> prepended to it.
Since the for loop insures that <font face="Courier New, Courier10 BT" size=3>$(i)</font>
is a single element list, the result is simple, but if <font face="Courier New, Courier10 BT" size=3>$(i)</font> had more than one
element (such as <font face="Courier New, Courier10 BT" size=3>[be media midi]</font>) the result would be:
<br>
<font face="Courier New, Courier10 BT" size=3>[-lbe -lmedia -lmidi]</font>.
<p>
Given <i>that</i> value of <font face="Courier New, Courier10 BT" size=3>$(i)</font>, the result of <font face="Courier New, Courier10 BT" size=3>$(i)$(i)</font> would be:
<br>
<font face="Courier New, Courier10 BT" size=3>[bebe bemedia bemidi mediabe mediamedia mediamidi midibe midimedia midimidi]</font>.
<br>
Try saying that three times fast.
<p>
Two final notes regarding variable expansion: if a list contains the null
string (""), the result of expansion is still a product, but only of
non-null elements.  For example, if a variable <font face="Courier New, Courier10 BT" size=3>$(x)</font> was the list <font face="Courier New, Courier10 BT" size=3>[A ""]</font>
and <font face="Courier New, Courier10 BT" size=3>$(y)</font> was <font face="Courier New, Courier10 BT" size=3>["" 1]</font>, the expansion of <font face="Courier New, Courier10 BT" size=3>*$(x)$(y)*</font> would
be <font face="Courier New, Courier10 BT" size=3>[*A* *A1* ** *1*]</font>. The other note is that any expansion that uses an
undefined variable results in an empty list.
<p>
After ProcessLibs is a similar string-processing rule:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># MkObjectDirs &lt;List of Source Files&gt; ;</font>
<font color=#006600>#   Makes the necessary sub-directories in the object target directory based</font>
<font color=#006600>#   on the sub-directories used for the source files.</font>
rule MkObjectDirs
{
    local dir ;
    
    for i in $(1)
    {
        dir = [ FDirName $(LOCATE_TARGET) $(i:D) ] ;
        Depends $(i:S=$(SUFOBJ)) : $(dir) ;
        MkDir $(dir) ;
    }
}
</pre></td></tr></table>
<p>
<br>
This rule is used to create sub-directories for the object files that mirror
the directory structure of the project source files. Similar to ProcessLibs, a
local variable is declared, and a for loop is used, which in this case iterates
over source file names. In the loop body the variable dir is set to be the
result of a call to the built-in FDirName rule, which takes the
items in the list passed to it and concatenates them with directory separators
in between each item.
<p>
The parameter to FDirName is a list containing the target
directory into which everything is built (defined later in the Jamfile-engine)
and the directory of the source file (that is what the <font face="Courier New, Courier10 BT" size=3>:D</font>
variable-modifier returns.) Then a dependency is set up between the object file for the
source file and the created directory name.
<p>
The <font face="Courier New, Courier10 BT" size=3>:S=</font> modifier used with <font face="Courier New, Courier10 BT" size=3>$(i)</font> replaces the file extension
of the variable with the given suffix, in this case the variable <font face="Courier New, Courier10 BT" size=3>$(SUFOBJ)</font>,
which is .o on BeOS. By creating this dependency between the object file and
the directory it is created in, we can ensure the directory is properly created
before the object file.
<p>
After the dependency is set up, the actual MkDir rule is called with the given directory.
This rule creates the given directory if it doesn&#039t already exist,
including any needed parent directories, like the GNU <font face="Courier New, Courier10 BT" size=3>mkdir</font> command with the <font face="Courier New, Courier10 BT" size=3>-p</font> option.
<p>
After the MkObjectDirs rule are a few more simple rules:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># RmApp &lt;Pseudotarget Name&gt; : &lt;Application Name&gt; ;</font>
<font color=#006600>#   Removes the given application file</font>
<font color=#006600>#   when the given pseudotarget is specified.</font>
rule RmApp
{
    Depends $(&lt;) : $(&gt;) ;
}

actions RmApp
{
    rm -rf "$(&gt;)"
}

<font color=#006600># RunApp &lt;Pseudotarget Name&gt; : &lt;Application Name&gt; ;</font>
<font color=#006600>#   Runs the given application in the background</font>
<font color=#006600>#   when the given pseudotarget is specified.</font>
rule RunApp
{
    Depends $(&lt;) : $(&gt;) ;
}

actions RunApp
{
    "$(&gt;)" &
}
</pre></td></tr></table>
<p>
<br>
<h4>Pseudotargets</h4>
These rules look very similar to AddResources, and their function in the
Jamfile-engine should be obvious. One thing that may not be obvious is what the
parameters are, particularly the first, pseudotarget name.
<p>
A pseudotarget is a
name that defines a target which can be specified on the command-line to jam,
but that is not really a file system target that can be created. This
distinction is specified using certain Jam rules, which will be described
later. Suffice it to say that when the pseudotargets passed into the above rules
are specified on the jam command-line, the actions for those rules will be run.
<p>
For example, if <font face="Courier New, Courier10 BT" size=3>RunApp test : $(APP) ;</font> was specified later in the Jamfile-
engine (which it is), running "jam test" on the command-line would run the
application in the background (after creating it if need be.)
<p>
Now for the next set of rules:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># InstallDriver1 &lt;Pseudotarget Name&gt; : &lt;Driver File&gt; ;</font>
<font color=#006600>#   Installs the given driver in the correct location</font>
<font color=#006600>#   when the given pseudotarget is specified.</font>
rule InstallDriver1
{
    Depends $(&lt;) : $(&gt;) ;
    USER_BIN_PATH = /boot/home/config/add-ons/kernel/drivers/bin ;
    USER_DEV_PATH = /boot/home/config/add-ons/kernel/drivers/dev ;
}

actions InstallDriver1
{
    copyattr --data "$(&gt;)" "$(USER_BIN_PATH)/$(&gt;:B)"
    mkdir -p $(USER_DEV_PATH)/$(DRIVER_PATH)
    ln -sf "$(USER_BIN_PATH)/$(&gt;:B)" "$(USER_DEV_PATH)/$(DRIVER_PATH)/$(&gt;:B)"
}

<font color=#006600># InstallDriver &lt;Pseudotarget Name&gt; : &lt;Driver File&gt; ;</font>
<font color=#006600>#   Installs the given driver in the correct location</font>
<font color=#006600>#   when the given pseudotarget is specified</font>
<font color=#006600>#   (after making sure that this is actually a driver)</font>
rule InstallDriver
{
    if ( $(TYPE) = DRIVER )
    {
        InstallDriver1 $(&lt;) : $(&gt;) ;
    }
}
</pre></td></tr></table>
<p>
<br>
These rules, as the names imply, are used for installing drivers.
The commands in the actions are taken almost verbatim from the Be
makefile-engine (as they say: if it ain&#039t broke, don&#039t fix it.)
<p>
The reason that there is an InstallDriver1 and InstallDriver rule is due to the
need to check the $(TYPE) variable before actually performing the action.
If this isn&#039t actually a driver, it does not make sense to try to install it
in the driver directories.  So the rule that should be called by users of this
rule-set is InstallDriver, which will do the right thing based on the given
type of BeOS project.  This style of naming (appending 1 to the rule name for
the worker rule) is used in the Jambase file, which is why it is used in the
Jamfile-engine as well.
<p>
Finally, the last two rules defined are:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># Link &lt;Application Name&gt; : &lt;List of Object Files&gt; ;</font>
<font color=#006600>#   Replaces the actions for the default Jam Link rule with one that</font>
<font color=#006600>#   handles spaces in application names.</font>
actions Link bind NEEDLIBS
{
    $(LINK) $(LINKFLAGS) -o "$(&lt;)" $(UNDEFS) $(&gt;) $(NEEDLIBS) $(LINKLIBS)
}

<font color=#006600># BeMain &lt;Application Name&gt; : &lt;List of Source Files&gt; ;</font>
<font color=#006600>#   This is the main rule that builds the project.</font>
rule BeMain
{
    MkObjectDirs $(&gt;) ;
    
    if ( $(TYPE) = STATIC )
    {
        Library $(&lt;) : $(&gt;) ;
    }
    else
    {
        Main $(&lt;) : $(&gt;) ;
    }
    
    if ( $(RSRCS) )
    {
        AddResources $(&lt;) : $(RSRCS) ;
    }
    
    MimeSet $(&lt;) ;
}
</pre></td></tr></table>
<p>
<br>
As the comment illustrates, the first "rule" is really just a
re-definition of the actions for the built-in Link rule.  The actions from the
Link rule in the Jambase have been changed by adding quotes around the
application name <font face="Courier New, Courier10 BT" size=3>$(&lt;)</font>.
<p>
This shows that any of the built-in Jam rules can be
modified freely in any Jamfiles you create.  In fact, the built-in Jambase can
be completely replaced by specifying the -f option to Jam on the command-line
(though this may not be too useful since most of Jam&#039s usefulness comes
from the rules defined in the built-in Jambase.)
<p>
<br>
<h4>The Main Rule</h4>
The final rule, BeMain, is the real work-horse in the Jamfile-engine: this is really what
builds the project. Because of all the work done in the rest of the Jamfile-
engine, however, this really is quite simple.
<p>
First, the MkObjectDirs rule is called with the project source files,
which will create the needed object directories as described above.
Then an if statement is used to determine if the type of project is a static library.
If it is, the built-in Jam rule Library is called, which compiles the given source files
and then archives them into a static library of the given name.
Otherwise the built-in Jam rule Main is called, which compiles the given source files
and then links them as the given application name.
<p>
At this point it should be mentioned that both Library and Main make use of the
Objects rule, which uses the Object rule, which is smart in that it looks at the
file extension of the given source file and then calls the appropriate rule to
compile it. Files that end with .cpp or .cc or .C are compiled with the C++
rule, while .c files are compiled with the Cc rule, and .l files are compiled
with Lex, etc. Thus sources can be a mixed list of any Jam-supported files and
they will all be compiled correctly and linked into one application or library.
(There is also a fairly easy way to add support for compiling other types of
files, such as Pascal or ASM files, for instance, which will be explained in the next article.)
<p>
The rest of the Jamfile-engine is mostly definitions of various variables, and
only a few parts of it use any Jam concepts that have not already been explained.
Those are the only parts that will be explained here, starting with this:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># Set the directory where object files and binaries will be created.</font>
<font color=#006600># The pre-defined Jam variable OSPLAT will indicate what platform we</font>
<font color=#006600># are on (X86 vs PPC, etc.)</font>
LOCATE_TARGET = obj.$(OSPLAT) ;
</pre></td></tr></table>
<p>
<br>
As described briefly in the explanation of the MkObjectDirs rule, this variable
defines where targets should be located, i.e. where they are created.  In this
case it is set to be "obj." with the platform appended.  The variable $(OSPLAT)
is one of the few variables actually compiled into Jam (and therefore not set
in Jambase), and it is an all capital description of the CPU type (such as X86,
PPC or SPARC.)
<p>
Jam runs on many platforms, and a properly written Jamfile
should be able to work on many of them, unmodified.  For example, the
Jamfile-engine should theoretically run on both x86 and PowerPC versions of BeOS
as it is today (the term theoretically is used here since no one has tested
the Jamfile-engine on a PowerPC machine yet.)
<p>
Also, though it is used in MkObjectsDir, LOCATE_TARGET is actually a variable from
the Jambase that is used extensively in all the built-in Jam rules.  Of course
one thing that a helpful Jamfile-engine user discovered is that despite the
setting of this variable, source files that exist in subdirectories are
created in similar subdirectories under LOCATE_TARGET, not directly in it.
This is why the MkObjectDirs rule was created, because otherwise the compiler
complains when it tries to put object files into non-existent directories.
<p>
After the LOCATE_TARGET definition comes a few more definitions:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># Set some defaults</font>
if ( ! $(NAME) )
{
    ECHO <font color=#660000>"No NAME defined!"</font> ;
    NAME = NameThisApp ;
}
if ( ! $(TYPE) )
{
    ECHO <font color=#660000>"No TYPE defined...defaulting to APP"</font> ;
    TYPE = APP ;
}
if ( ! $(SRCS) )
{
    ECHO <font color=#660000>"NO SRCS defined...defaulting to *.cpp in current directory"</font> ;
    SRCS = [ GLOB . : *.cpp ] ;
}
if ( ! $(DRIVER_PATH) )
{
    DRIVER_PATH = misc ;
}
</pre></td></tr></table>
<p>
<br>
These are all probably pretty obvious.  The few interesting points are:
<p>
<ul>
	<li><font face="Courier New, Courier10 BT" size=3>( ! $(SOME_VAR) )</font> will be true for an undefined or empty variable.
	<li>The GLOB rule returns any files that match the given criteria in the given
	directory. The pattern rules will be explained more fully in the next article.
	<li>The syntax of the square brackets ([]) around a rule invocation expands the
	results of that rule into a list which can then be assigned to a variable.
</ul>
<p>
Following the definitions above is a large section that defines variables based on
the CPU type. Again, most of this is based on the Be makefile-engine, with a few
tweaks because of Jam&#039s more capable syntax. One of those tweaks is the use of
the Jam <font face="Courier New, Courier10 BT" size=3>switch</font> statement instead of a series of if statements.
Since that is the only new piece of Jam syntax, that is all that will be described
from this section of the Jamfile-engine:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
switch $(OPTIMIZE)
{
    case FULL : OPTIMIZER = -O3 ;
    case SOME : OPTIMIZER = -O1 ;
    case NONE : OPTIMIZER = -O0 ;
    
    <font color=#006600># Default to FULL</font>
    case * : OPTIMIZER = -O3 ;
}
</pre></td></tr></table>
<p>
The Jam <font face="Courier New, Courier10 BT" size=3>switch</font> statement probably looks familiar to C or C++ programmers.
Overall it works the same, but has a few nicer features. For instance, it does
not do matching based on simple numeric equivalence, but on string matching.
<p>
In the above case, if $(OPTIMIZE) is set to any of the explicitly listed cases, the
matching statement gets run. There is no need for a break statement as in C,
only the matching statement gets run. There also is no default branch, though
the same functionality can be had by using * as the matching criteria, as done
above. In fact, the GLOB statement described above actually uses the matching
syntax from the switch statement (switch was implemented before GLOB), and again
the matching syntax will be more fully described in the next article.
<p>
There is one more new Jam rule that is part of this processor-dependent section of
the Jamfile-engine, right at the end:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
else
{
    EXIT <font color=#660000>"Your platform is unsupported"</font> ;
}
</pre></td></tr></table>
<p>
<br>
The EXIT rule prints out the given statement and then halts the execution of Jam.
This is best used in cases of serious error, as done above when the
$(OSPLAT) is not X86 or PPC.
<p>
The next series of statements in the Jamfile-engine are platform-independent
settings. The only thing really new here is the definition of the various
pseudotargets used by the Jamfile-engine:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600># Set up the driverinstall target...this makes it easy to install drivers</font>
<font color=#006600># for testing</font>
Always driverinstall ;
NotFile driverinstall ;
InstallDriver driverinstall : $(NAME) ;

<font color=#006600># Set up the rmapp target...this removes only the application</font>
Always rmapp ;
NotFile rmapp ;
RmApp rmapp : $(NAME) ;

<font color=#006600># Set up the test target...this runs the application in the background</font>
<font color=#006600>#Always test ;</font>
NotFile test ;
RunApp test : $(NAME) ;
</pre></td></tr></table>
<p>
<br>
As mentioned above when describing the RmApp, RunApp, and InstallDriver rules, a
pseudotarget is defined and then passed to each rule to act as the target that
can be passed to Jam on the command-line to perform the given action. In the
case of RunApp, "test" is used, which is set up as a pseudotarget by
the calls to the built-in Jam rules Always and NotFile.
<p>
The Always rule marks a target so that it is always updated, even if it exists.
This rule can be used with real file-based targets as well as pseudotargets,
though in general it is most useful with pseudotargets. If this rule is not used,
the pseudotarget will only work the first time (generally when the target it
depends on is first created.)
<p>
The NotFile rule is the rule that actually makes a target a pseudotarget,
by informing Jam that it isn&#039t really a file, so it cannot be built.
When combined with Always, this allows convenient targets to be specified when
calling Jam, so that for instance "jam rmapp" will remove an application created
by the Jamfile-engine, "jam test" will run that application, and "jam driverinstall"
will install a driver in the correct place.
<p>
Finally, the last statement in the Jamfile-engine is a call to the
previously-described BeMain rule:
<p>
<table bgcolor=#E0E0E0 width=600><tr><td><pre>
<font color=#006600>##-------------------------------------------------------------------</font>
<font color=#006600>## OK, let&#039s build</font>
<font color=#006600>##-------------------------------------------------------------------</font>
BeMain $(NAME) : $(SRCS) ;
</pre></td></tr></table>
<p>
<br>
So by now you should understand quite a bit more about Jam and also how the
mysterious Jamfile-engine works. As you can see, the Jamfile-engine really
isn&#039t that complicated, and overall is quite a bit simpler than the Be
makefile-engine (though with all my comments they are about the same length.)
Also it should be evident that though Jam is probably more complicated than
make, the extra functionality is very useful, and the platform-independence of
most Jamfiles alleviates the need for complicated configure scripts.
<p>
The next article in this series will be a Jam cookbook that will describe
how various build problems and challenges can be solved with Jam. The author already has
a few ideas for some "recipes", but I would ask that anyone reading this who has
other challenges, please e-mail them to me. Especially things that you think
"cannot be done with Jam." You may be right, but I&#039ll try my best to show how it can be done.
<p>
I&#039ll end with a small anecdote: I frequently see people working on OpenBeOS
complain that "I would write a Jamfile, but I don&#039t know how." My hope is that
by the end of this series of articles, no one has to say that again.
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:147) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="147">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Family Fun</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:michaelphipps@users.sourceforge.net">Michael Phipps</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>A few weeks ago, we had a major ice storm in upstate NY. We lost power for a weekend, had trees falling down all over and many roads were closed. During the time without power, many families rediscovered the concept that, well, talking to each other isn&#039t so bad. In fact, it is a Good Thing.
</p> 

<p>I was talking this over with a friend who is a guitarist. His eyes lit up as he related a quote from an interview that he had read sometime back--that musicians only "go solo" when they can&#039t find anyone who wants to do what they are doing. That the fun of it is sharing it with others.
</p> 

<p>All of which led me to think about family life in the USA in 2003. Parents often-times talk about kids and parenting and so on, and I am not an exception to this. One of the complaints that I hear from other parents is that their kids spend too much time in solo activities. TV, most video games, chess, and reading are the most popular. Reality and human interaction are not as interesting and stimulating as these things, I think. People are drawn in by the depth of the experience and held there by the ability to be excited and entertained with a minimal effort.
</p> 

<p>I started to think, more positively, about why parents and kids don&#039t share as many activities as they used to. One hundred or more years ago, parents and kids used to work together on everything. Partially because they needed to survive and pass on the accumulated skills, but partially because they had no other source of entertainment. Families 
<b>together</b> instead of just inhabiting the same building like roommates. One of the conclusions that I came to is that many of the activities that people used to share are not common practice anymore. Quilting, for example. Some people still do it. But it used to be that *everyone* did it. You couldn&#039t buy blankets, at least not everyone and not everywhere. While the women were quilting, the men were carving or sharpening tools, etc. The kids learned to do what their parents did. There was constant interaction. The parents and the children shared activities and interests.
</p> 

<p>Obviously today this doesn&#039t happen as much. Most people don&#039t go home and practice their work. If they need something, they go buy it at a store instead of making it. Adults have more leisure time than ever before in history. This is a good thing, in many ways. The separation of children from parents is a bad thing, though. Parents and children share far fewer common interests and activities. Sure, Dad might play baseball or football with the kids. And Mom might play dolls or bake cookies or whatever (not trying to be sexist, but a realist). But that is not the majority of the interaction between parent and child.
</p> 

<p>So the solution is activities that both parents and children enjoy. There is a limit to the number of games of CandyLand and Chutes and Ladders that you can play (parents, you know what I am talking about). But what sorts of things can you do with a 4 year old who can&#039t read? What game can you both play, enjoy, and have an equal chance of winning? I will tell you--there is nothing that a kid can see through faster than when an adult is deceiving them. Even when they want to believe it, they know in their hearts that it is not true.
</p> 

<p>Which led me to think of an interview that I had read about M.U.L.E.--a game that I have heard tons of good things about, but never actually played. Apparently, the players compete against each other, yet have to work together, as well. That is the focal point of the idea which I am writing--fair and friendly competition where working together is good for everyone. I have noticed this concept working really well in multi-player real time strategy games (RTS) like, say, Starcraft. The team members work together but at the same time try to get the highest individual score. In some RTS&#039s, some team work aspects are directly encouraged--one example is Age Of Empires, where giving a team mate resources gets you points.
</p> 

<p>So I thought about a few game ideas that would be fun for the whole family. The first idea is a trading game, where everyone&#039s product is a raw material or a component for someone else&#039s. The computer would "know" a player&#039s skill level and help them more or less--sort of like the advisors in Sim City, but actually helpful. An example--a child may decide to run a lemonade stand. Mom might grow lemons. Dad might have a paper cup factory. The sibling may decide to supply water or sugar.
</p> 

<p>Some other ideas include building bridges, rescuing people stranded on a flooding island, and playing team sports. Traditional board games, trivia, word puzzles, mysteries, role playing games, and maybe even musical composition could be pulled off. Complex enough to hold a parent&#039s interest, simple enough for a child.
</p> 

<p>OK, so what? These are just quasi-educational games. Nothing really new. The key, here is that the PC/game console form factor is not conducive to these sorts of games. One screen isn&#039t really comfortable for multi-player. The designer has two choices - either some players are not "represented" on screen at one time or the screen is very divided and cluttered. Each player should have their own display device. The same sort of issues exist for controllers - small enough for Junior&#039s hands is cramped for Dad, not to mention that only N people can have a controller in hand at one time. Every player should also have a control mechanism of some sort.
</p> 

<p>The solution is ultra-lightweight LCD panels with touchscreens. Think high-res, color Palm-like devices with bluetooth built-in. They communicate with the home&#039s PC (which runs as a server). The games really run on the server, but the display runs on the hand held devices (HHDs). Maybe a "master" display, showing scores or some sort of global display runs on the server&#039s video. The HHDs are the players&#039 interface to the game. This also allows "private" information. Think, say, of the tiles in Scrabble. Players can talk and work together while still competing. The common display shows the commonly known facts.
</p> 

<p>All of this is just a crazy idea--I certainly don&#039t have the time to put something like this together. But if I did, I think that something like OpenBeOS would be the OS to do it. It is small and lightweight enough to run on a very low power tablet device. I would be willing to bet that the kernel, app server, and the media kit could fit into a meg of memory, with proper tuning. 8 megs of memory on a small handheld device, with a low end processor (maybe Transmeta or maybe the Via processors). It would be diskless and boot from the server, taking at most a few seconds to stream the kernel and such to the device. I would think that a couple of AA batteries would last a very long time under those circumstances. One could even use a Palm Pilot with wireless capability as a prototype...
</p>
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
               	</font>
               	<tr><td><img src="images/spacer.gif" width=1 height=20></td></tr>
          	</table>
                                        </font>
                                   </td>
                                   <!-- / Content -->
                                   
                                   <td width=20 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=20>&nbsp;</td>
                                   <td width=1 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   
                                   
                                   
                                   <td width=10 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>

                              </tr>
                              <tr><td colspan=9 height=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td></tr>
                         </table>
                         <!-- / Main Table -->
                         


                    </body>
                    <!-- / Body -->
                    </html>