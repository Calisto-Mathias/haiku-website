
               <html>
                    <!-- Heading -->
                    <head>
                         <title>OpenBeOS Project - Displaying Newsletter</title>
                         <meta name="Keywords" content="OpenBeOS, BeOS, OBOS, operating system, developer">
                         <meta http-equiv="Cache-Control" content="no-cache">
                         <meta http-equiv="Pragma" content="no-cache">
                    </head>
                    <!-- / Heading -->
                    <!-- Body -->
                    <body bgcolor="#ffffff" leftmargin=5 topmargin=5>

                         <!-- Top Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0 bgcolor="#a7afbb">

                              <!-- Logo -->
                              <tr valign="bottom"><td><img src="images/logo.png" border=0></td></tr>
                              <!-- / Logo -->

                              <!-- Slogan -->
                              <tr valign="top">
                                   <td width="100%">
                                        <img src="images/spacer.gif" height=1 width=160><img src="images/slogan.png">
                                   </td>
                              </tr>
                              <!-- / Slogan -->

                              <tr><td colspan=2><img src="images/spacer.gif" height=6 width=1></td></tr>
                         
                         </table>
                         <!-- / Top Table -->
                         
                         <!-- Main Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0>
                              <tr valign="top">
                              
                                                  

                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>
                                   <td width=16 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=15>&nbsp;</td>
                                   
                                   <!-- Content -->
                                   <td width="100%">
                                        <font size="-1" face="Verdana, Arial">
                                        
     	    	<table width="99%" cellspacing=0 cellpadding=0 border=0>
           	     <tr>
                	     <td height="12"><a name="top">&nbsp;</a><img src="images/spacer.gif" heigh="12" width=1></td>
               	</tr>
               	<tr>
                         <td>
                    	     <img src="images/N.png" align="absmiddle" border=0>
                              <img src="images/spacer.gif" height=1 width=20>
                              <font face="Verdana, Arial" size="+2" color="#331111">Displaying Newsletter<div align="right"><font size="-1"><a href="index.html">Newsletter Archive</a></font></div></font>
                              <img src="images/spacer.gif" heigh=20 width=1>
                         </td>
               	</tr>
               	<font size="-1" face="Verdana, Arial">
               	
               <tr>
                    <td><font color="#113355" face="Verdana,Arial"><b>Issue 11, 09 Feb 2002</b></font>
                         
                    </td>
               </tr>
               <tr><td height="6"><img src="images/spacer.gif" height="6"></td></tr>
               <!-- Newsletter Header Links -->
               <tr>
                    <td bgcolor=#eeeeee>
                    
                         <table width="100%" cellspacing="2" cellpadding="0" border="0">
                              <tr valign="top">
                                   <td bgcolor="#f6f6f6">
                                        <font face="verdana,arial" size="-1">
                                        <br><br>&nbsp;&nbsp;<b><font color="">In This Issue:</font></b>
                                        <ul type="square">
                                             <li><a href="#34">Binary Compatibility in 3 Easy Steps!</a>&nbsp; by Erik Jakowatz</li><li><a href="#35">Generic Programming: Encouraging Code Re-Use</a>&nbsp; by Matthew Hounsel</li><li><a href="#36">State of the Union</a>&nbsp; by Michael Phipps</li>
                                        </ul>
                                        </font>
                                   </td>
                              </tr>
                         </table>
               
                    </td>
               </tr>
               <!-- / Newsletter Header Links -->
               
		     <!-- Newsletter Article (ID:34) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="34">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Binary Compatibility in 3 Easy Steps!</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:ejakowatz@users.sf.net">Erik Jakowatz</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         In the early days of the OpenBeOS project, a debate raged concerning one of the projects
primary goals: maintaining binary compatibility with BeOS R5.  The idea was that the
only way an effort to rewrite BeOS would be successful was if folks could continue
running the apps they already had.
<p>
Certainly, a lot of software available for BeOS is
open source or actively maintained -- these apps could just be recompiled if necessary.
Others -- PostMaster, Gobe's Productive suite and a few other crucial apps -- weren't
likely to get rebuilt, either because the original author had stopped maintenance
without being kind enough to release the source, or because it just wouldn't be
commercially feasible.<p>
Some said that we were crazy; that it couldn't be done.  Thankfully, cooler heads
prevailed and we're well on our way to a binary compatible clone of R5.<p>
"But wait!" you cry. "How did the cooler heads which prevailed know that the holy grail
of binary compatibility was achievable?"  I'm so glad you asked!  Keeping reading and be
enlightened, Grasshopper.<p>
There are three basic issues that have to be addressed to ensure binary compatibility:
<ul type="square">
	<li>
		<b>Names must be identical</b><br>
		This includes class and structure names as well as public, protected and global
		function and variable names.
	</li>
	<li>
		<b>Object sizes must be identical</b><br>
		Classes must contain the same number of bytes of data; global variables must
		be the same size.  Maybe BGlobalVar should've been an <code>int32</code>
		instead of an <code>int16</code>, but we're stuck with it now.
	</li>
	<li>
		<b>Virtual function table layout must be identical</b><br>
		The most cryptic and confusing aspect of maintaining binary compatibility.
		The issue essentially boils down to this: for any given class, there must
		be the same number of virtual functions, declared in the same order as the
		original.
	</li>
</ul>
<p>
<b>The Nitty Gritty</b>
<p>
"Good grief!" you say. "How on earth do I keep all this stuff straight?"  Ah,
Grasshopper, it is easier that you might imagine.  Just follow these steps, and you
should be binary compatible in no time!
<ol>
	<li>
		<b>Make a copy of the appropriate Be header file</b><br>
		This is now your header file.  You may need to change a thing or two, but what
		you can (or will need to) change is quite limited, and discussed below.
	</li>
	<li>
		<b>Implement public, protected and virtual functions</b><br>
		In the course of doing this, you may discover that there are some private
		non-virtual function declarations that you just don't use.  Feel free to axe
		them!  Since they're private, nobody using the class will miss them, and
		because they're not virtual, they don't effect the vtable layout.  Conversely,
		if you find a need to add some private, non-virtual functions, go right ahead
		(for the very same reasons).
	</li>
	<li>
		<b>Make sure you don't change the number of bytes used for data</b><br>
		There are two situations that can make this seem difficult.  First, there
		may be data members that you don't use in your reimplementation.  You can
		just leave them (safe, but a little messy) or you can add the extra members'
		bytes to the class's "unused" data array.  An example will make this clear.<br>
		Let's say we have a class BFoo:<br>
		<code>
        <pre>
    class BFoo {
        public:
            BFoo();
            void SomeFunc();
        private:
            int32 fBar;
            int32 fQux;
            char  fZig;
            int32 fUnused[2];
    };
        </pre>
        </code>
		The Be engineers that originally wrote this BFoo purposely added some data
		padding in the form of an array of 2 <code>int32</code>s (they did this with
		most classes in the API).  Now let's suppose in your implementation, you
		really didn't need <code>fQux</code>.  You can add <code>fQux</code>'s bytes
		into <code>fUnused</code>:<br>
		<code>
        <pre>
    class BFoo
    {
        ...
        private:
            int32 fBar;
            char  fZig;
            int32 fUnused[3];
    };
        </pre>
        </code>
		Nothing could be easier!
		<p>
		"But what if I don't need <code>fZig</code>, either?" you wonder. "It's only
		one byte, not four like an <code>int32</code>!"  Have no fear!  Just rename it
		"<code>fUnusedChar</code>" and be done with it.<p>
		The second situation that can make preserving object size tricky is if there
		aren't <i>enough</i> bytes of data available.  Building on our cheesy BFoo
		example, let's suppose that rather than getting rid of <code>fQux</code> and
		<code>fZig</code>, you actually needed to <i>add</i> another 4
		<code>int32</code>s worth of data: <code>fNewData1</code> through
		<code>fNewData4</code>.  The original implementation of BFoo has two extra
		<code>int32</code>s which we can use, but that leaves us two <code>int32</code>s
		short.  What to do?  The easiest thing to do is create a data structure to hold
		your new data and convert one of the <code>fUnused</code> items into a pointer
		to that structure:
		<code>
        <pre>
    // Foo.h
    struct _BFooData_;
    class BFoo
    {
        public:
            BFoo();
            ~BFoo();
            void SomeFunc();
        private:
           int32 fBar;
           char  fZig;
           _BFooData_* fNewData;
           int32 fUnused[1];
    };
    // Foo.cpp
    struct _BFooData_
    {
        int32 fNewData1;
        int32 fNewData2;
        int32 fNewData3;
        int32 fNewData4;
    };
    BFoo::BFoo()
    {
        fNewData = new _BFooData_;
    }
    BFoo::~BFoo()
    {
        delete fNewData;
    }
        </pre>
        </code>
		Voila!  More data without making the class bigger.  Notice the added
		destructor; make sure you're cleaning up your new (dynamically allocated) data.
	</li>
</ol>
And there you have it: Binary Compatibility in 3 Easy Steps!
<p>
Questions, comments, or corrections?  Please 
<a href="mailto:erik@cgsoftware.com">let me know!</a>

                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:35) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="35">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Generic Programming: Encouraging Code Re-Use</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:mat_geek@yahoo.com.au">Matthew Hounsel</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         Generic Programming is a simple ideal. Generic Programming is the art of taking a set of common code and generalising an abstraction that performs the general case and which can be easily specialised to handle unusual cases.</p>
<p>The best examples of Generic Programming are Design Patterns. Design Patterns are a general solution to a set of problems commonly encountered in computer programs. The definitive text is "Design Patterns: Elements of Reusable Object-Oriented Software." This text defines the solution to many architecture problems, such as The Singleton - A class with only one instance e.g. BApplication, or Iterators - Sequential access to a collection e.g. BEntryList::GetNextEntry()</p>
<p>Design patterns are a solution; there is no code for you to use.</p>
<p>While reading many journal articles on the STL and generic programming, I realised I didn't understand any of it. When I read the explanation of Patterns and Iterators in particular Generic Programming began to make sense.</p>
<p><strong>Generic Programming is about not writing code.</strong> We hate rewriting code; it is time consuming and prevents us from doing the work we want. Generic programming is simply abstracting the common general solution from a set of them. To use generic code you only need to specialise obscure details. "Modern C++ Design: Generic Programming and Design Patterns Applied" shows how this can be done, and I hope to introduce these ideas to you. FYI: This book discusses how to use the generic capabilities of C++ to implement your design. The author provides an implementation of The Singleton, Functors and other patterns.</p>
<p>I recommend you read both these books, although you might want to brush up on basic templates before reading "Modern C++ Design" and this article.</p>
<p><br>
<b>Patterns of BeOS</b>
<p>Beginning an application for BeOS is not difficult. The applications mostly follow a single pattern.</p>
<p><code>
    Define the type of the main window, this will inherit BWindow.<br />
    Define the type of the application, this will inherit BApplication.
    <br /><br />
    Define the applications constructor to create a main window.<br />
    Define the applications run function to show the created window.<br />
    <br />
    Define the main routine to create an instance of the application<br />
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then run that application.
</code></p>
<p>The general case varies only on the type of main window to create and the application signature. To get a clearer idea lets look at the code for a sample application.</p>
<p><code>
<pre>class MBApplication : public BApplication {
    typedef BApplication super;
public:
    MBApplication( void )
        : super( SIGNATURE_VALUE )
    {
        the_win = new WINDOW_TYPE();
    }
    // No destructor as it crashes app.
    virtual void ReadyToRun(void) {
        the_win-&gt;Show();        
    }
protected:
    WINDOW_TYPE * the_win;
};
int main( void ) {
    be_app = NULL;
        
    int errorlevel = 0;
    try {
        // Automatically assigned to be_app
        new MBApplication( );
        
        if( B_OK != be_app-&gt;InitCheck() ) {
            errorlevel = APP_INIT_FAIL_VALUE;
        } else {
            be_app-&gt;Run();
            errorlevel = 0;
        }
        
    } catch( ... ) {
        // Ensure children clean up.
        delete be_app;
        throw;
    }
    delete be_app;
        
    return errorlevel;
}
</pre></code></p>
<p>Many applications only differ in the values of SIGNATURE_VALUE, INIT_FAIL_VALUE and the type WINDOW_TYPE. C programmers might define them as pre-processor macros, that's generally not a good solution. As C++ programmers, we have templates. A template is essentially a compiler variable. We can define these three values as template parameters of the class and function, T for template type and TV for template value.</p>
<p><code>
<pre><b>template&lt; class T_Window, char const * TV_SIGNATURE &gt;</b>
class MBApplication : public BApplication {
    typedef BApplication super;
public:
    MBApplication( void )
        : super( <b>TV_SIGNATURE</b> )
    {
        the_win = new <b>T_Window()</b>;
    }
    // No destructor as it crashes app.
    virtual void ReadyToRun(void) {
        the_win-&gt;Show();        
    }
private:
    <b>T_Window</b> * the_win;
};
<b>template&lt; class T_Application, int TV_INIT_FAIL &gt;</b>
int <b>MBMain</b>( void ) {
    be_app = NULL;
        
    int errorlevel = 0;
    try {
        // Automatically assigned to be_app
        new <b>T_Application</b>();
        
        if( B_OK != be_app-&gt;InitCheck() ) {
            errorlevel = <b>TV_INIT_FAIL;</b>
        } else {
            be_app-&gt;Run();
            errorlevel = 0;
        }
        
    } catch( ... ) {
        // Ensure children clean up.
        delete be_app;
        throw;
    }
    delete be_app;
        
    return errorlevel;
}
</pre></code></p>
<p>Notice how little code changes to make it generic. There is still the issue of how to use this generic code. You will still need to have your Application Window and your main function. Except your main function now looks like this one.</p><p><code>
<pre>int main( void ) {
    return <b>MBMain&lt; MBApplication&lt; AWindow, APP_SIG &gt;, OOPS &gt;</b>();
}
</pre></code></p>
<p>This is syntax is called template instantiation. You are telling the compiler, you want this template entity created with these values. Above, you are creating a <code>MBApplication</code> <b>class</b> that uses an <code>AWindow</code> and has <code>APP_SIG</code> as its signature. You then tell the compiler to create a <code>MBMain</code> <b>function</b> that uses your application and returns <code>OOPS</code> if it can't start. Generic code is shown here by the fact you can use the <code>MBMain</code>	function it with any application type. Even an application not derived from <code>MBAppplication</code>. We will try to keep our function and class separate.</p>
<p><br>
<b>There are always problems</b>
<p>There is a problem with the above code: it restricts the signature and initialisation failure value to compile time constants. Also GCC on Be doesn't like that, any attempts to get them to play nicely result in internal compiler errors.</p>
<p>The solution to these problems are to consider that the signature of an application and its initialisation failure as characteristic traits of the class. Generic algorithms have to deal with widely varying types and usage patterns, often needing to vary themselves depending upon a class's traits. If your application had to run a special loading function before it could start you might want to disable the default constructor. As such the construction would be a trait of the class, it would be implemented as a call to <code>new</code> for most classes and specialised for different classes.</p>
<p>Since the implementation of template classes can vary dependant upon their arguments, C++ allows you to specialise templates. That is, you can provide a special implementation for a certain type. The standard library has a specialised version for vectors of boolean values. This allows the vector to save space and compact a thirty two element vector from one hundred and twenty eight bytes down to four bytes, a 32:1 saving.</p>
<p>We declare a trait class as an external type that takes the type it describes the character for, as a template parameter. We then specialise it for our application. To specialise you copy the existing code you supply the parameter for the template. Please Note: that &gt;&gt; will be interpreted as shift by the compiler so remember to leave a space.</p>
<p><code>
<pre>template&lt; class T_Application &gt;
class MBApplicationTraits {
public:
    static inline char const * Signature( void ) {
        return "application/x-vnd.unknown-mbapp.unknown";
    }
    static inline int InitFailureValue( void ) {
        return 1;
    }
};
template&lt; &gt;
class MBApplicationTraits&lt; MBApplication&lt; AWindow &gt; &gt; {
public:
    static inline char const * Signature( void ) {
        return "application/x-vnd.unknown-mbapp.unknown";
    }
    static inline int InitFailureValue( void ) {
        return 1;
    }
};
</pre></code></p>
<p>We remove the fixed parameters from the generic application and main routine above, replace the parameters with calls to the trait class.</p>
<p><code>
<pre>template&lt; class T_Window &gt;
class MBApplication : public BApplication {
    MBApplication( void )
        : super( MBApplicationTraits &lt; MBApplication &lt; T_Window &gt; &gt;
        		::Signature() )
    // ...
}
// And
template&lt; class T_Application &gt;
int MBMain( void ) {
    // ...
        if( B_OK != be_app-&gt;InitCheck() ) {
            errorlevel = MBApplicationTraits&lt; T_Application &gt;
            			::InitFailureValue();
    // ...
}
</pre></code></p>
<p>The above code works perfectly out of the box. A macro, MB_APPLICATION_TRAITS_M, is provided to make it easier to use. Now you only need the sample code, a window class and a reworked version of the following code to create a simple application for BeOS. You can sub-class the application class, with a fixed or template parameter, if you wish to augment it.</p>
<p><code>
<pre>MB_APPLICATION_TRAITS_M(
	MBApplication&lt; AWindow &gt;,
	"application/x-vnd.mfh-mbapp.sample",
	1 )
int main( void ) {
    return MBMain&lt; MBApplication&lt; AWindow &gt; &gt;();
}
</pre></code></p>
<p><strong>Generic Programming is about not writing code.</strong> Once you have written the code several times you can step back and see its general form. You can use templates to provide "out of the box" code to use. You can use the powerful idiom of traits to extract the type specific and design specific code and generalise your solution further still. 
<p><br>
<b>Wait there's more ...</b>
<p>The current trait class is limited by being unable to access any runtime data. The <code>InitFailValue</code> function for example can not retrieve a value from the application class. It can use <code>be_app</code>, but using global variables often indicates poor design and in this case, there is a better one.</p>
<p>If we pass a pointer to the application to both trait functions, the application can be accessed as a normal class. Remember the trait class is not a friend by default. If we pass each function a pointer and it is the pointers type that is the template parameter then we no longer need to have a class template. This is because we can make the functions' templates.</p>
<p>Not only does this give us cleaner access to class data but it also cleans our code up substantially. We no longer need to explicitly specify the trait class for the signature or the return value. Nor do we have to specialise the entire class. We can just specialise the trait functions we need. It is not much of a saving, but it is a good example of template functions. There is one caveat, however, we can not just pass <code>be_app</code> to <code>InitFailValue</code> we must cast it to the correct type.</p>
<p><code>
<pre>class MBApplicationTraits {
public:
    template&lt; class T_Application &gt;
    static inline char const * Signature( T_Application * the_app ) {
        return "application/x-vnd.unknown-mbapp.unknown";
    }
    template&lt; class T_Application &gt;
    static inline int InitFailureValue( T_Application * the_app ) {
        return 1;
    }
};
template&lt; class T_Window &gt;
class MBApplication : public BApplication {
    MBApplication( void )
        : super( MBApplicationTraits::Signature( this ) )
    // ...
};
// And
template&lt; class T_Application &gt;
int MBMain( void ) {
    // ...
        if( B_OK != be_app-&gt;InitCheck() ) {
            // Cast or it will use the BApplication version
            errorlevel = MBApplicationTraits::InitFailureValue(
                static_cast&lt; T_Application* &gt;( be_app ) );
    // ...
}
// Specialize traits for MBApplication&lt; AWindow &gt;
template&lt; &gt;
    char const * MBApplicationTraits::
    Signature&lt; MBApplication&lt; AWindow &gt; &gt;
    ( MBApplication&lt; AWindow &gt; * the_app ) \
        { return "application/x-vnd.mfh-mbapp.sample"; }
// The main stays the same.
int main( void ) {
    return MBMain&lt; MBApplication&lt; AWindow &gt; &gt;();
}
</pre></code>
<p>Generalising the creation of the window and application will be dealt with in another article. There is a new concept called policies that perfectly capture that problem.</p>
<p>
<br><i>Source Code:</i><br>
<a href="samples/MBApplication.zip">MBApplication.zip</a>
<p><br>
<b>Bibliography</b>
<p><cite>
	Andrei Alexandrescu (1995)<br>
	"Modern C++ Design: Generic Programming and Design Patterns Applied."<br>
	Boston: Addison Wesley. ISBN: 0-201-70431-5.<br>
	WWW:<br>
	<a href="http://www.awl.com/cseng/titles/0-201-70431-5">
		http://www.awl.com/cseng/titles/0-201-70431-5
	</a>
</cite>
<p><br>
<cite>
	Gamma, Erich, Richard Helm, Ralph Johnson, John Vlissides (1995)<br>
	"Design Patterns: Elements of Reusable Object-Oriented Software."<br>
	Reading, MA: Addison Wesley. 
</cite>

                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:36) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="36">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">State of the Union</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:michaelphipps@users.sf.net">Michael Phipps</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         OpenBeOS was proposed as an idea on August 18, 2001. We are quickly approaching our 6 month anniversary. I thought that this would be an appropriate time to discuss where we are, where we are going and how to get there.</p>
<p><br>
<b>So. Where are we? </b>
<p>
We are far more organized. Basically, we have built an organization from the ground up. An evolving organization that is neither too rigid nor too large. We have a great team. Aaron, our recruiter gets volunteers placed in teams and gets their info to Daniel and I for the web site and SourceForge access. Daniel designed and built our web site from the ground up. Rich is our new project manager; he will be keeping track of team statuses and helping to put a more organized overall project plan together. Deej is our newsletter editor, possibly one of our most well received ideas - the newsletter, that is. &nbsp;&nbsp; ;) &nbsp;&nbsp; We have a dozen or so team leaders, each responsible for a portion of the OBOS. They communicate with their team memebers, with each other and with Rich and I. We will be updating the web site more as we get into the groove with statuses. </p>
<p>
We have a well defined plan. We are recreating R5, to begin with. We are using a home made network stack and application server. We are basing our kernel on NewOS. We are not building browsers, Windows emulators, games, graphics packages, movie makers or anything else. Not that any of those are bad, but they aren't what we are doing today. We are focused on the OS, and we will stay focused on the OS. We will be binary compatible, barring any huge, impossible-to-overcome, provable issues. We will (obviously) be source code compatible. We promise that we will work on x86 machines. Not every one, but as many as possible. PPC support would be nice, if enough people join who are interested in doing so.</p>
<p>
We have code! By the time you read this, there should be a new build system in source control. The old system was a blind stab in the dark. The newer system was designed and built to fix the badness in the old system. There are several kits that have made massive progress, others that are making progress and some that need more help and time. Some of the kits are large and difficult, while others are more easy to implement. Some pieces, as well, are "freebies". Mail kit, courtesy of Dr Zoidberg, and OpenTracker, courtesy of Be and Axel are good examples.</p>
<p>
We have interest! I can't even begin to tell you about all of the interesting stuff going on. Some of it is confidential. Companies that want to use OBOS, but can't disclose that to the general public, yet. I get about half a dozen emails a week about this sort of thing. We have a couple of distributors who are interested in building OBOS distros, when we have everything in place. We have a mailing list that is often exceptionally busy. We have tons of hits on the web site.</p>
<p><br>
<b>All good. Where do we go from here?</b>
<p>
The time is coming (very soon) for a first, partial release. Some of the easier kits and some of the freebies will be released shortly. THIS IS NOT A FULL RELEASE! There is no kernel. No app_kit. No networking. These will be kit by kit replacements for R5. This is a chance to get our work out to the beta testers, to draw a line in the sand and say that some things are done, and to transition people to their next part of the project. Look for this soon!</p>
<p>
The other, bigger kits are making a lot of progress. I am sure that you have seen some of these things on the web site:
<ul type="square">
<li>Media Kit plays sounds
<li>App Server prototypes
<li>Kernel reading a Be created driver
</ul>
<p>
While these things do not a release make, they are milestones that let you know that progress is being made. And that is a good thing. While we don't want to release any code before its time, we certainly also realize how important it is to have regular updates.</p>
<p><br>
<b>How do we get there?</b>
<p>
The way I see it, we are in the middle of the project. The initial excitement is over. Most of the people who are going to hear of OBOS have. Most of the people who are going to join have done so. This is the part of the race that separates the dedicated from the band wagon members. At the beginning, there is a lot of excitement about what can be done. At the end, there is a lot of excitement about what has been done. Results are visible and fixing bugs can be fun at that point. The middle is the part of the race where people realize that running is hard work. Harder than they expected. That they won't have as much time or be able to code as fast as they thought. It is easy to become discouraged during these times. This is the danger in the middle of the project, and the reason that this interim release is so important.</p>
<p>
If you are a developer, I say GO GO GO! For years, we watched Be and advised them. This is our chance to *BE* them. Pardon the pun. If you are a tester, do your backups and get ready. If you are an interested observer, help out! There are still a lot of things that need to be done. Can't code? Test. Can't test? Buy apps. Can't buy apps? Volunteer with <a href="http://www.beunited.org">BeUnited</a>. They are a volunteer driven organization who wants to make an OBOS distro. They need a lot of ***DEDICATED*** help.</p>
<p>
This project has been a lot of work and a lot of fun, so far. I have learned more than I ever thought possible. And I learn more every day. I hope that it has been fun and educational for everyone else. Keep your chins up and heads held high. We *WILL* get through R1. We *CAN* do this. And when we are finished, we will have earned a place in the industry that few can claim. After all. How many of your friends can say that they wrote their own OS?

                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
               	</font>
               	<tr><td><img src="images/spacer.gif" width=1 height=20></td></tr>
          	</table>
                                        </font>
                                   </td>
                                   <!-- / Content -->
                                   
                                   <td width=20 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=20>&nbsp;</td>
                                   <td width=1 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   
                                   
                                   
                                   <td width=10 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>

                              </tr>
                              <tr><td colspan=9 height=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td></tr>
                         </table>
                         <!-- / Main Table -->
                         


                    </body>
                    <!-- / Body -->
                    </html>