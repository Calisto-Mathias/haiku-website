
               <html>
                    <!-- Heading -->
                    <head>
                         <title>OpenBeOS Project - Displaying Newsletter</title>
                         <meta name="Keywords" content="OpenBeOS, BeOS, OBOS, operating system, developer">
                         <meta http-equiv="Cache-Control" content="no-cache">
                         <meta http-equiv="Pragma" content="no-cache">
                    </head>
                    <!-- / Heading -->
                    <!-- Body -->
                    <body bgcolor="#ffffff" leftmargin=5 topmargin=5>

                         <!-- Top Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0 bgcolor="#a7afbb">

                              <!-- Logo -->
                              <tr valign="bottom"><td><img src="images/logo.png" border=0></td></tr>
                              <!-- / Logo -->

                              <!-- Slogan -->
                              <tr valign="top">
                                   <td width="100%">
                                        <img src="images/spacer.gif" height=1 width=160><img src="images/slogan.png">
                                   </td>
                              </tr>
                              <!-- / Slogan -->

                              <tr><td colspan=2><img src="images/spacer.gif" height=6 width=1></td></tr>
                         
                         </table>
                         <!-- / Top Table -->
                         
                         <!-- Main Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0>
                              <tr valign="top">
                              
                                                  

                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>
                                   <td width=16 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=15>&nbsp;</td>
                                   
                                   <!-- Content -->
                                   <td width="100%">
                                        <font size="-1" face="Verdana, Arial">
                                        
     	    	<table width="99%" cellspacing=0 cellpadding=0 border=0>
           	     <tr>
                	     <td height="12"><a name="top">&nbsp;</a><img src="images/spacer.gif" heigh="12" width=1></td>
               	</tr>
               	<tr>
                         <td>
                    	     <img src="images/N.png" align="absmiddle" border=0>
                              <img src="images/spacer.gif" height=1 width=20>
                              <font face="Verdana, Arial" size="+2" color="#331111">Displaying Newsletter<div align="right"><font size="-1"><a href="index.html">Newsletter Archive</a></font></div></font>
                              <img src="images/spacer.gif" heigh=20 width=1>
                         </td>
               	</tr>
               	<font size="-1" face="Verdana, Arial">
               	
               <tr>
                    <td><font color="#113355" face="Verdana,Arial"><b>Issue 51, 15 Feb 2004</b></font>
                         
                    </td>
               </tr>
               <tr><td height="6"><img src="images/spacer.gif" height="6"></td></tr>
               <!-- Newsletter Header Links -->
               <tr>
                    <td bgcolor=#eeeeee>
                    
                         <table width="100%" cellspacing="2" cellpadding="0" border="0">
                              <tr valign="top">
                                   <td bgcolor="#f6f6f6">
                                        <font face="verdana,arial" size="-1">
                                        <br><br>&nbsp;&nbsp;<b><font color="">In This Issue:</font></b>
                                        <ul type="square">
                                             <li><a href="#182">OBOS App_Server Overview</a>&nbsp; by DarkWyrm and Michael Phipps</li><li><a href="#181">How to Write a BeOS R5 Printer Driver</a>&nbsp; by Michael Pfeiffer</li><li><a href="#183">Against Directories</a>&nbsp; by Michael Phipps</li>
                                        </ul>
                                        </font>
                                   </td>
                              </tr>
                         </table>
               
                    </td>
               </tr>
               <!-- / Newsletter Header Links -->
               
		     <!-- Newsletter Article (ID:182) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="182">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">OBOS App_Server Overview</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:bpmagic@columbus.rr.com">DarkWyrm and Michael Phipps</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>Recently, I asked DarkWyrm to give me a quick overview of the app_server. It is a piece of OBOS that I do not really understand; I wanted to start looking at code and I was looking for an introduction to help me get started. He provided most of this article; my work has been mostly editorial with a little bit of clarification and introduction to make it more appropriate to a newsletter.</p>

<p>The app_server is a process within BeOS--an application, if you will. It runs in user space, not kernel mode. Applications communicate with app_server via the Interface Kit. The IK provides all of the controls--sliders, buttons, text panels, etc.--and calls on app_server to draw everything. As such, I am sure that you can imagine that app_server is a complex piece of code. Performance and threading are critical to its success. Like any complex piece of software, it is broken into logical subsystems and different classes to make it comprehensible to its developers. For app_server, these subsystems are Fonts, Desktop, Management, Graphics, and Support.</p>

<h3>Fonts</h3>

<p>Our font rendering is provided by FreeType2. FT2 is a complete, open source font rendering system that is used in many other projects. Their development has saved us a great deal of time and effort and it is appreciated. The Fonts subsystem is technically the smallest, being limited to just a few classes: FontServer, FontFamily, FontStyle, and ServerFont. The main component for managing fonts is the FontServer. When the app_server starts, the font server iterates over the standard BeOS font directories, finding the fonts kept there, and creates a list of available font families and styles using the appropriate classes. Most work which needs done with fonts for OBOS will end up being done with ServerFont, which is the server-side equivalent of BFont. Almost any objects which need to work with fonts should use ServerFont.  The Fonts subsystem is not considered to be complete.</p>

<h3>Desktop</h3>

<p>Desktop, in this case, does not refer to OpenTracker, folders, or the Deskbar. It refers to the portion of the app_server that deals with the windows, managing the monitor(s) and the drawing area, and "clipping"--only drawing what is actually visible. The OBOS Desktop is, for the most part, organized hierarchically with respect to class stucture. The Desktop class is at the top, performing high-level tasks, such as loading and initializing a display driver, handling window focus, sending input messages to the appropriate handler, and managing the data needed by global API functions like set_scroll_bar_info() and the like. Beneath the Desktop object is the RootLayer object, which performs two tasks: it manages all sublayers and keeps track of the available ServerScreen and Workspace objects. The next level down is occupied by ServerScreen, which at this point, is little-used but lays the foundation for the support of multiple monitors. At this point, its purpose is to house a DisplayDriver object. Also at this third level of management is the WinBorder class, which provides a way to manage window objects in the display hierarchy. While each WinBorder object technically "owns" its own instance of a Decorator, its Decorator object gives the WinBorder its shape according to its window size. The lowest echelon of the hierarchy is occupied by Layer objects. Layers are the server counterpart to BView and also provides the base code for redraw and clipping for it and its subclasses. ColorSet is devoted to handling the color attributes of the desktop, such as window tab color, panel background color, etc. It is written to be source compatible with Dano. If this proves to be a problem with binary compatibility, steps will be taken to ensure that it is BC. SysCursor is a tweaked-up ServerBitmap which is used to hold BCursor data.</p>

<h3>Management</h3>

<p>Management refers mostly to message handling--interfacing the app_server with the other system processes that need to communicate with it. The management classes are AppServer, ServerApp, ServerWindow, SessionStreamReader, BitmapManager, and CursorManager. AppServer performs very basic startup tasks: it spawns housekeeping threads, loads an appropriate Decorator add-on, and allocates global management objects. Once the system init is done, it watches for a select few kinds of messages--mostly app creation, but also for server shutdown when in test mode. The threads it spawns--Poller and Picasso--process input messages and check for dead applications, respectively. ServerApp objects are counterparts to BApplications and provide handling for BApplication services. Their message ports are also utilized for global function calls and creation of ServerWindows. ServerWindows are the counterparts to BWindows and provide server-side functionality for numerous BWindow calls. Graphics messages are translated into DisplayDriver calls by its DispatchGraphicsMessage method. SessionStreamReader is utilized by ServerWindow to handle graphics messages because graphics messages are streamed--cached on the client side and sent in blocks when the cache fills or when a sync is required. It is necessary to allow it to peacefully coexist with the normal packet-based messaging protocols without catastrophic results popping up from time-to-time. BitmapManager provides services for allocating and freeing ServerBitmaps and the buffer memory associated with them. The CursorManager tracks all ServerCursors used by the system. It also provides services for the new System Cursor API to allow for more consistency and flexibility across the GUI.</p>

<h3>Graphics</h3>

<p>The entire subsystem is built upon the DisplayDriver class, which provides a context-independent graphics interface. This allows for testing by rendering to a DirectWindow, a WindowScreen, or a BBitmap/BView combination in addition to being able to utilize regular hardware and hardware acceleration. One change from R5 is that hardware cursors are not supported, in favor of software cursors, which are much more flexible.  Be used hardware cursors for performance reasons: Older video cards, especially those without accelerated blitting, needed that performance boost. Modern video cards do not. The API for utilizing 32-bit cursors is currently private and will remain so until R2. PNGDump contains one function and is used for saving the contents of the framebuffer to a PNG file. This replaces the huge BMP that the R5 app server creates. PatternHandler is used by DisplayDriver implementations to convert patterns into (x,y) coordinates. ServerPicture is used for server-side BPicture support. As of this writing, quite a lot of work remains to be done to implement BPicture support. Decorator objects are used to define and draw the border and tab of each window. The server also  contains its own default decorator so that the system can function even if no decorators are otherwise installed.</p>

<h3>Support</h3>

<p>These classes don&#039t have a cohesive place anywhere inside the other four groups.</p>
<ul>
<li><i>Globals.h</i> contains the definitions of window types, and Will probably have more definitions and things in the future. 
<li><i>Angle</i> provides a reasonably fast means for getting trig function values for angles via a lookup table. This is currently needed only for internal use by the DisplayDriver.
<li><i>ServerProtocol.h</i> provides message code definitions for server communications.
<li><i>SharedObject.h</i> provides a rudimentary shared-object base class. It probably will become the basis for ServerBitmap in the future.
<li><i>CursorData</i> defines the default system cursors. It&#039s used only by the CursorManager.
<li><i>TokenHandler</i> provides a simple means to obtain tokens with the option to exclude values.
<li><i>RGBColor</i> is a generic color encapsulation class which allows colors to be specified in 8-, 15-, 16-, or 32-bit values. Color caching is performed for speedier lookups when converting to 8-bit color.
<li><i>Utils</i> is a generic file for miscellaneous utility functions, mostly for working with BMessages and message codes.
<li><i>RectUtils</i> contains functions for working around existing R5 bugs in working with BRegions and BRects. This file will disappear after R1 is released.
<li><i>ServerBitmap</i> is the server-side counterpart to BBitmap. It also serves as the basis for ServerCursor. ServerBitmaps are not directly created or destroyed when used for BBitmap support--the BitmapManager is used so that the memory pool is properly taken care of.
<li><i>areafunc.c</i> and <i>bget.c</i> provide the BGET public domain pool allocator and functions to interface it with BeOS areas.
<li><i>FMWList</i> contains a list class for managing floating and modal windows.
<li><i>ServerConfig.h</i> is a file used to configure compile-time options for the app_server. Within it are definitions for the filenames and paths for various things like app_server settings, current decorator settings, and the name for the file containing the list of fonts available to the system.
</ul>
<p>The app_server has (obviously) made a lot of progress, even since the prototypes. The efforts of Gabe, Adi and DarkWyrm and their teammates are vastly appreciated!</p>

                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:181) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="181">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">How to Write a BeOS R5 Printer Driver</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:michael.pfeiffer@utanet.at">Michael Pfeiffer</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>A <i>printer driver</i> in BeOS R5 is an add-on that exports a specific C interface. This add-on is used by the print_server to add a new printer, configure a page, configure the print job, and print the print job on the printer.  This article describes how the print_server interfaces with the printer driver.</p>

<p>
The print_server is responsible for maintaining common settings. <code>BMessage</code> objects are used to pass settings from the print_server to a printer driver and vice versa. If the printer driver has to return a <code>BMessage</code> object and wants to show the successful completion of an operation, it has to set the field <code>what</code> to the value <code>&#039okok&#039</code>. 
To indicate an error, the preferred method is to return <code>NULL</code>. In some cases the print_server interprets a value in <code>what</code> other than &#039okok&#039 as the failure of an operation. A printer driver should not rely on this; instead, it should return <code>NULL</code>.
</p>

<p>
A <i>print job</i> is a file, generated by a printing application using the Interface Kit class <code>BPrintJob</code> (see Figure 1).  This file contains archived <code>BPicture</code> objects--one for each call made to <code>BPrintJob::DrawView()</code>. A raster printer driver, for example, can use the <code>BPicture</code> objects for each page and draw them into a <code>BBitmap</code> object and convert the pixels in the <code>BBitmap</code> object into the format the printer understands. The driver can make changes to the content of the BPicture, including dithering and color correction. There is no standard or common code for these features in R5.
</p>

<p>When a printer driver is requested to print a print job it uses a <i>transport add-on</i> to transfer data to the printer. Transport add-ons know how to write to an individual device (parallel, USB, network, etc.) Separating transports from drivers allows R5 to work with, for example, a printer on a USB port or the same printer on a parallel port with only one driver. It also makes writing the drivers simpler: the driver outputs a "stream" of data, without having to know how it is delivered.
</p>

<center>
<img src="beos_r5_printing_overview.png"><br>
<b>Figure 1:</b> BeOS R5 Printing Overview
</center>

<h3>Driver Location</h3>

<p>System printer drivers that are installed with the OS are located in <code>B_BEOS_ADDONS_DIRECTORY</code> in the subfolder <i>Print</i> (i.e., <i>/boot/beos/system/add-ons/Print</i>).
<br>Printer drivers installed by the user are usually placed into <code>B_USER_ADDONS_DIRECTORY</code> in the subfolder <i>Print</i> (i.e., <i>/boot/home/config/add-ons/Print</i>). 
</p>

<p>Transport add-ons (like Print To File, Parallel Port, and USB Port) are located in a folder named <i>transport</i> inside of the system or user printer driver folder.

<h3>The Life of a Printer Driver</h3>


<h4>Installing the Printer Driver</h4>

<p>To install a printer driver, the driver has to be moved into one of the printer driver folders. Printer drivers should not link to shared libraries other than those provided by the OS--third-party libraries should be statically linked instead. This helps to avoid version conflicts.</p>

<h4>Adding a New Printer</h4>
<p>
Users add a new printer to the system using the Printers preflet. They select a <i>printer name</i>, <i>printer type</i>, and <i>transport add-on</i>. The preference application creates a <i>spool folder</i> with the name of the printer in <code>B_USER_PRINTERS_DIRECTORY</code> (i.e., <i>/boot/home/config/settings/printers</i>). The name of the transport add-on is stored in the spool folder&#039s file attribute named <code>transport</code>. The type code of this attribute is B_STRING_TYPE.</p>

<p>
The print_server, when notified of the new printer, calls the printer driver to configure the printer. The function prototype within the printer driver for this is:
</p>

<blockquote><pre>
char* add_printer(char* printer_name);
</pre></blockquote>

<p>
This gives the printer driver the chance to open a window for configuration of the printer model. The configuration can be stored in the attributes of the spool folder. On success the printer driver should return the pointer to the string <code>printer_name</code> or <code>NULL</code> on failure.
</p>


<h4>Configuring the Page</h4>

<p>
When an application calls <code>BPrintJob::ConfigPage()</code>, the print_server requests that the printer driver configure the page by calling:
</p>

<blockquote><pre>
BMessage* config_page(BNode* spool_folder, BMessage* settings);
</pre></blockquote>

<p>
The printer server calls this function with <code>spool_folder</code>, a pointer to a <code>BNode</code> object whose path is the spool folder, so the printer driver can access its attributes. It also passes <code>settings</code>, a pointer to a <code>BMessage</code> object that contains the previous page settings, if any. At the very least, the page size and orientation have to be specified.
</p>

<p>
The printer driver usually opens a window to let the user select the page size, orientation, and (optionally) other settings; these other settings may be printer specific.
The mandatory fields are:
</p>

<p>
<table border cellpadding=4>
<th>Field</th>
<th>Type Code</th>
<th>Meaning</th>
<tr>
<td><code>printable_rect</code></td>
<td><code>B_RECT_TYPE</code></td>
<td>The printable rectangle in 1/72 inches. That is the area the printer is able to write into.</td>
<tr>
<td><code>paper_rect</code></td>
<td><code>B_RECT_TYPE</code></td>
<td>The paper rectangle in 1/72 inches.</td>
<tr>
<td><code>orientation</code></td>
<td><code>B_INT32_TYPE</code></td>
<td>0 ... portrait, 1 ... landscape. </td>
<tr>
<td><code>xres</code></td>
<td><code>B_INT32_TYPE</code></td>
<td>Horizontal DPI.</td>
<tr>
<td><code>yres</code></td>
<td><code>B_INT32_TYPE</code></td>
<td>Vertical DPI.</td>
</table>
</p>

<p>
If the configuration was successful, a new <code>BMessage</code> object with the settings is returned.  If it fails, <code>NULL</code> has to be returned (e.g. in response to the user clicking the Cancel button in the page setup window).
</p>

<h4>Configuring the Print Job</h4>

<p>
The main purpose of the configuration of the print job is to let the user select the range of pages to be printed and the number of copies of each page that should be printed. Again, printer-driver-specific settings can be added.
</p>

<p>
The print_server calls this function with the same parameters as it does when configuring the page:
</p>
<blockquote><pre>
BMessage* config_job(BNode* spool_folder, BMessage* settings);
</pre></blockquote>


<code>Settings</code> contains the fields from page configuration, which should not be changed. The mandatory fields that have to be added or changed are:
<p>
<table border cellpadding=4>
<th>Field</th>
<th>Type Code</th>
<th>Meaning</th>
<tr>
<td><code>first_page</code></td>
<td><code>B_INT32_TYPE</code></td>
<td>The page number of the first page to be printed. Starts with 1.</td>
<tr>
<td><code>last_page</code></td>
<td><code>B_INT32_TYPE</code></td>
<td>The page number of the last page to be printed. If all pages should be printed its value should be <code>MAX_INT32</code> (= 0x7fffffffL).</td>
<tr>
<td><code>copies</code></td>
<td><code>B_INT32_TYPE</code></td>
<td>The number of copies.</td>
</table>
</p>

On success, a new <code>BMessage</code> object with the settings should be returned; otherwise <code>NULL</code> has to be returned.


<h3>Using a Transport Add-On</h3>

<p>
The printer driver has to load the transport add-on associated with the printer. The name of the transport add-on is stored in the file attribute <code>transport</code> of the spool folder. The driver should first look into the user&#039s printer folder (start at <code>B_USER_ADDONS_DIRECTORY</code> then proceed to <i>Print/transport</i>) to find the named transport add-on there. If it fails, it should look into the system printer folder (start at <code>B_BEOS_ADDONS_DIRECTORY</code> then proceed to <i>Print/transport</i>).
</p>

<p>
The transport add-on exports two C functions:
</p>

<blockquote><pre>
BDataIO* init_transport(BMessage *settings);
void     exit_transport(void);
</pre></blockquote>

<p>
<code>init_transport()</code> is passed a <code>BMessage</code> object with a field <code>printer_file</code> of type <code>B_STRING_TYPE</code> containing the path to the spool folder.  On success it  returns a <code>BDataIO</code> object and <code>NULL</code> on failure. 

The <code>BDataIO</code> object can be used to write data to the printer.
</p>

<p>
The printer driver must <b>not</b> delete the <code>BDataIO</code> object. Instead it has to call <code>exit_transport()</code> and then unload the transport add-on.
</p>

<p>
Sample code can be found in class <code>PrintTransport</code>&#039s method <code>Open()</code> in the folder <i><a href="http://cvs.sourceforge.net/viewcvs.py/open-beos/current/src/add-ons/print/shared">current/src/add-ons/print/shared</a></i> in the OBOS source code repository. The header file <i>PrintTransport.h</i> can be found in <i><a href="http://cvs.sourceforge.net/viewcvs.py/open-beos/current/headers/private/print">current/headers/private/print</a></i>.
</p>

<h4>Printing the Print Job</h4>

<p>
Now we come to the core of a printer driver. This is the prototype of the function that is called by the print_server when the print job is ready to be processed:
</p>

<blockquote><pre>
BMessage* take_job(BFile* print_job, BNode* spool_folder, BMessage* settings);
</pre></blockquote>

<p>
The print job can be read using the file <code>print_job</code>. Its file format is explained below. Again the attributes of the spool folder can be accessed using <code>spool_folder</code> and the <code>settings</code> from the page configuration are also available, e.g. to get the page size.
</p>

<p>
To write data to the printer, the printer driver has to load the transport add-on and create a <code>BDataIO</code> object as explained in the section entitled <i>Using a Transport Add-on</i>.
</p>

<p>To read the print job the class <code>PrintJobReader</code> from the OBOS source code repository can be used. This code snippet demonstrates how <code>PrintJobReader</code> can be used: 
</p>

<blockquote><pre>
PrintJobReader reader(print_job);
if (reader.InitCheck() == B_OK) {
  // the settings stored in the print job
  BMessage* settings = reader.JobSettings();
  
  // page number of the first page
  int32 firstPage = reader.FirstPage();
  
  // page number of the last page
  int32 lastPage = reader.LastPage();
  
  // paper and printable rectangle
  BRect paperRect = reader.PaperRect();
  BRect printableRect = reader.PrintableRect();
  
  // resolution
  int32 xdpi, ydpi;
  reader.GetResolution(&xdpi, &ydpi);
  
  int32 pages = reader.NumberOfPages();
  // for each page
  for (int page = 0; page < pages; page ++) {
    
    PrintJobPage pjp;
    
    if (reader.GetPage(page, pjp) == B_OK) { 
      BPicture picture; 
      BPoint point; 
      BRect rect;
      
      // for each picture on page
      while (pjp.NextPicture(picture, point, rect) == B_OK) {
        // do some thing with the picture at point
      }
    }
  }
}
</pre></blockquote>


<p>
What the printer driver does with the data from the print job is printer dependent and is not within the scope of this article. Sample source code can be found in the OBOS source code repository. For raster printer drivers see OBOS printer drivers Canon LIPS, PCL5, or PCL6. For "vector" printer drivers see the OBOS PDF printer driver.
</p>

<table border>
<th>Print Job File Format</th>
<tr>
<td><pre>
struct  print_file_header {
  int32  version;
  int32  page_count;
  off_t  first_page;
  int32  _reserved_3_;
  int32  _reserved_4_;
  int32  _reserved_5_;
};
</pre></td></tr><tr><td>
This is declared in <i>PrintJob.h</i>.  In the print job file, the header is followed by a flattened <code>BMessage</code> object containing the settings that are passed to <code>take_job()</code>.
<br>
The print job file contains <code>page_count</code> <i>page sections</i>. The first starts at file offset <code>first_page</code>.</td></tr>
</table>

<p><table border>
<th>Page Section</td>
<tr>
<td><pre>
struct  page_header {
  int32   picture_count;
  off_t   next_page;
  int32   _reserved[10];
};
</pre></td>
<tr>
<td>
This is followed by <code>picture_count</code> <i>picture sections</i>.
<br>
The next page section starts at file offset <code>next_page</code>.
</td>
</table>

<p><table border>
<th>Picture Section</td>
<tr>
<td><pre>
struct _picture_header_ {
  BPoint  point;
  BRect  rect;
};
</pre></td>
<tr>
<td>
This is followed by a flattened <code>BPicture</code> object.
</td>
</table></p>



<h4>Removing a Printer</h4>

<p>
With the Printers preference application a printer can be removed. This deletes the printer folder from <code>B_USER_PRINTERS_DIRECTORY</code> if no pending print jobs exist.
</p>


<h4>Uninstalling a Printer Driver</h4>

<p>
A printer driver should be removed only if all printers have been removed with the Printers preflet. To remove the printer driver, the printer driver add-on has to be deleted from the system or user printer driver folder. There is little advantage to doing this--printer drivers are small and do not add to boot time or decrease system performance.
</p>


<h4>Updating a Printer Driver</h4>

<p>
Usually if a new version of a printer driver should be installed it is not necessary to remove the added printers from the system. In most cases it is sufficient to replace the printer driver add-on.
</p>


<h3>Issues to Consider When Writing a (Printer Driver) Add-On</h3>

<p>
A printer driver add-on is loaded on demand and usually unloaded as soon as it is not used any more. This means global states cannot be stored in global variables of the printer driver add-on. As mentioned already, the printer driver can store global states in an attribute of the spool folder.
</p>

<p>
It is also possible that multiple instances of the printer driver add-on are loaded and used at the same time (e.g. when the printer prints a print job and the user configures a page at the same time).
</p>

<p>
Multiple threads started by the printer driver can also be an issue. The printer driver has to ensure that all threads that have been started inside of the driver have exited before the driver returns from a function. E.g., when the printer driver opens a window for the configuration of a page in <code>config_page()</code>, a separate thread for the window is started. <code>config_page()</code> has to wait until the window is closed and the object that represents the window is completely destroyed, otherwise it could happen that the printer driver unloads the printer driver add-on while the window thread is still running. This will lead to a memory access violation because the window thread still accesses code in the add-on that is not loaded any more.
</p>


<h3>Open BeOS Source Code Locations</h3>

<table border>
<th>Files</th>
<th>Location</th>

<tr>
<td><i>PrintJobReader.cpp</i></td>
<td><i><a href="http://cvs.sourceforge.net/viewcvs.py/open-beos/current/src/add-ons/print/shared/">current/src/add-ons/print/shared</a></i></td>

<tr>
<td><i>PrintJobReader.h</i></td>
<td><i><a href="http://cvs.sourceforge.net/viewcvs.py/open-beos/current/headers/private/print/">current/headers/private/print</a></i></td>

<tr>
<td>Printer Drivers</td>
<td><i><a href="http://cvs.sourceforge.net/viewcvs.py/open-beos/current/src/add-ons/print/">current/src/add-ons/print</a></i></td>

<tr>
<td>Transport Protocols</td>
<td><i><a href="http://cvs.sourceforge.net/viewcvs.py/open-beos/current/src/add-ons/print/transports/">current/src/add-ons/print/transports</a></i></td>
</table>
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:183) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="183">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Against Directories</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:michaelphipps@users.sourceforge.net">Michael Phipps</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>Let me start out by saying that I am not "against" directories. It is more like "rethinking" directories. We have been talking on the Glass Elevator list about queries and how to make them more useful for some time now. There is a pretty broad consensus that we should try to bring more use of queries into R2 and beyond, that we should help the end user to use them far more than R5 does. While not a "killer app", queries can be, at the very least, an "attacker app": one of those little features that you really miss when you move to other operating systems. As a result of some serious consideration of what I know about how people use computers, it seems to me that, in many ways, directories may not make sense anymore. Beginning users struggle with them. Many people just don&#039t use them--they fill their desktop with all of their files, or deposit everything into a large, flat "My Documents" folder.  Advanced users become frustrated with them because they are forced into only one organizational method. They can&#039t easily search for files except along the lines that they first organized their files.</p>

<p>If you take a graphic designer, for example, she might organize her files by client. If Client 1 wants a piece of stock clipart, she has three choices. One is to put her only copy of that clip art in that client&#039s folder. This makes it difficult to find again. Her second choice is to keep it in a "stock" folder. This defeats her purposes in a few ways. One is that the folder for the client is no longer a "pick it up and go"--she needs to include some of the stock folder as well. Another is that she needs to remember what clip art a customer needs. A third is that this defeats the "last directory used" concept that most file requesters use--going automatically to the last folder that the user selected. The graphic designer is now forced to "ping pong" between two or more directories to complete her work. For these reasons, her third option, the link, was invented. There are two varieties of links: hard and soft. Soft links are much like references or shortcuts in Windows. 
They contain a path to the "real" filename. Hard links are a directory entry that points to the same data as another directory entry. Each has issues and difficulties. Links are "just different enough" that users need to be aware of them and consider them. For example, if our graphic artist wants to copy files to a CD, she may well need to tell the burning software to include the original file rather than the link (for soft links). Hard links cannot cross volumes: You can&#039t make a hard link from Disk 1 to Disk 2.  None of the options above, though, really make it feasible to ask questions like "which customers use clip art ABC?"</p>

<p>Directories have problems. We started by discussing all of the "cool things" we could do with queries. Add a tab to the file requester allowing you to do queries on the fly for the file that you are looking for and you have an easier system. We considered some ideas about what metadata should exist by default. The system provides filename, creation date, mod date, mime type, file size, etc. Additional possibilities include resolution (for images), MP3 tags, document type (for text files), etc.--anything that the system can reliably autogenerate. Users could add their own attributes to files to make it easier for them to find things. The core problem that this generates is that it is more work for the end user to do--assigning values. Then it hit me--if we convince end users to replace directories with attributes, it decreases their work and increases the system&#039s usefulness.</p>

<p>This proposal was met with some resistance, because directories have been around a very long time and have solved organizational needs for a long time. I would like to discuss some of the objections here and react to them.</p>

<p>The first is stability--that directories are more stable and queries are more dynamic. That directories only change on command. I would respond that queries change in the same way as directories--when you want them to. If you choose a very dynamic parameter for your query (file size, for example, or last_mod_date), you will have folders that seem random. But that also makes sense--if you told a secretary that you want all of the newest memos on your desk at all times, you wouldn&#039t expect the older ones to remain.</p>

<p>Another is identity--that directories provide one and only one clear path to each file. This is completely true. I don&#039t see a lot of value in it, to be honest. In fact, with hard links, it is not true. BeOS doesn&#039t have them, but Unixes that I have used do. It doesn&#039t disturb me all that much when I see that there are a bunch of hard links to a file--that there is more than one way to get there.</p>

<p>The notion of hierarchy is brought up--that the hierarchy of files that a directory provides brings value. That queries are "opt-out" instead of "opt-in". Much of this depends on how you structure your queries. Sure, if you say "type=text" and nothing more, you get a lot of files. This is not radically different, though, from going to "My Documents" and saying "ls -R", recursively listing everything in your documents. If you instead say "type=text and project=obos-editorials", this is a lot like saying "ls -R &#039My Documents/obos-editorials&#039". In a similar vein, the ability of the hierarchical tree to be divided into subtrees is brought up. You can do things like crawl the whole tree in pieces. This is more powerfully done with queries, though. Pick an attribute, divide up the possible results any way that you like, and run separate queries. So long as there is only one value associated with one attribute, this works well.</p>

<p>Queries make "drag and drop organization" a little bit more of a challenge. For example, if you organized your directories of music by genre then artist, you can assign an artist&#039s music by dragging and dropping them into the genre of choice. That is a little tougher with queries--you would have to assign attributes. For a simple query (genre=blues) this is OK, but for (genre=blues or genre=jazz), this is harder. Various possibilities of a GUI to support this were discussed. The issue comes from the extra power of queries. You can make queries that you can&#039t make with folders. One way to solve this solution is the same way that file permissions are handled in Windows--multiply select a bunch of files, assign a set of permissions and click OK. </p>

<p>Temporarily collecting files with queries is different than with directories. With a directory, I can drag and drop files into a temp directory, then copy the whole thing to a CD. With queries, you would need to assign the files a common attribute which does not get burned to the CD and gets removed as the files are burned. This is a bit of a shuffle around. It does have an advantage, though: The files still match their original queries. So, using backups for example, you could deal with backups by creating a "backed up" attribute of type datetime. Creating a new backup would be an easy query: "last_mod_date>backed_up". While the backup application is running, other applications could still access those files.</p>

<p>Finally, dealing with other filesystems (non-BFS) is more complex without directories. The whole directory API must exist to support interfaces with ext, ntfs, iso9660, udf, fat, FTP and others. Some method of manipulating directories must continue to exist as long as we must coexist. I understand and accept that. That doesn&#039t mean that we need to allow others to dictate our future.</p>

<p>Queries have a vast number of advantages over unidirectional organizational schemes. They allow the users to ask questions in the way that makes sense to them. We have all seen classic Star Trek, in which they use the computer like a librarian--"Show me the files on Midas 5". That is the sort of power that a well built query system can bring to OBOS. The ability to work the way that you think at the moment, not the way that you (or a dev) thought of some time in the past.</p>


                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
               	</font>
               	<tr><td><img src="images/spacer.gif" width=1 height=20></td></tr>
          	</table>
                                        </font>
                                   </td>
                                   <!-- / Content -->
                                   
                                   <td width=20 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=20>&nbsp;</td>
                                   <td width=1 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   
                                   
                                   
                                   <td width=10 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>

                              </tr>
                              <tr><td colspan=9 height=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td></tr>
                         </table>
                         <!-- / Main Table -->
                         


                    </body>
                    <!-- / Body -->
                    </html>