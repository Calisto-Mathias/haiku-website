
               <html>
                    <!-- Heading -->
                    <head>
                         <title>OpenBeOS Project - Displaying Newsletter</title>
                         <meta name="Keywords" content="OpenBeOS, BeOS, OBOS, operating system, developer">
                         <meta http-equiv="Cache-Control" content="no-cache">
                         <meta http-equiv="Pragma" content="no-cache">
                    </head>
                    <!-- / Heading -->
                    <!-- Body -->
                    <body bgcolor="#ffffff" leftmargin=5 topmargin=5>

                         <!-- Top Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0 bgcolor="#a7afbb">

                              <!-- Logo -->
                              <tr valign="bottom"><td><img src="images/logo.png" border=0></td></tr>
                              <!-- / Logo -->

                              <!-- Slogan -->
                              <tr valign="top">
                                   <td width="100%">
                                        <img src="images/spacer.gif" height=1 width=160><img src="images/slogan.png">
                                   </td>
                              </tr>
                              <!-- / Slogan -->

                              <tr><td colspan=2><img src="images/spacer.gif" height=6 width=1></td></tr>
                         
                         </table>
                         <!-- / Top Table -->
                         
                         <!-- Main Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0>
                              <tr valign="top">
                              
                                                  

                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>
                                   <td width=16 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=15>&nbsp;</td>
                                   
                                   <!-- Content -->
                                   <td width="100%">
                                        <font size="-1" face="Verdana, Arial">
                                        
     	    	<table width="99%" cellspacing=0 cellpadding=0 border=0>
           	     <tr>
                	     <td height="12"><a name="top">&nbsp;</a><img src="images/spacer.gif" heigh="12" width=1></td>
               	</tr>
               	<tr>
                         <td>
                    	     <img src="images/N.png" align="absmiddle" border=0>
                              <img src="images/spacer.gif" height=1 width=20>
                              <font face="Verdana, Arial" size="+2" color="#331111">Displaying Newsletter<div align="right"><font size="-1"><a href="index.html">Newsletter Archive</a></font></div></font>
                              <img src="images/spacer.gif" heigh=20 width=1>
                         </td>
               	</tr>
               	<font size="-1" face="Verdana, Arial">
               	
               <tr>
                    <td><font color="#113355" face="Verdana,Arial"><b>Issue 50, 14 Dec 2003</b></font>
                         
                    </td>
               </tr>
               <tr><td height="6"><img src="images/spacer.gif" height="6"></td></tr>
               <!-- Newsletter Header Links -->
               <tr>
                    <td bgcolor=#eeeeee>
                    
                         <table width="100%" cellspacing="2" cellpadding="0" border="0">
                              <tr valign="top">
                                   <td bgcolor="#f6f6f6">
                                        <font face="verdana,arial" size="-1">
                                        <br><br>&nbsp;&nbsp;<b><font color="">In This Issue:</font></b>
                                        <ul type="square">
                                             <li><a href="#176">Editor's Note</a>&nbsp; by Kevin Field</li><li><a href="#178">System Logging</a>&nbsp; by Axel D&ouml;rfler</li><li><a href="#179">The &quot;virtualdrive&quot; driver</a>&nbsp; by Axel D&ouml;rfler </li><li><a href="#180">Total User Experience</a>&nbsp; by Michael Phipps</li>
                                        </ul>
                                        </font>
                                   </td>
                              </tr>
                         </table>
               
                    </td>
               </tr>
               <!-- / Newsletter Header Links -->
               
		     <!-- Newsletter Article (ID:176) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="176">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Editor's Note</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:kev@brantaero.com">Kevin Field</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>Well, I could say what I said back in August about trying to get newsletter editions out more often, but instead I&#039ll just say this:  When the OBOS developers are quiet, you know it&#039s because they&#039re working through the tough parts.  Now give it up for our newsletter writers, who, despite the busiest of schedules, have cranked out something for you to enjoy!
</p> 
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:178) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="178">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">System Logging</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:axeld@users.sourceforge.net ">Axel D&ouml;rfler</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                                 <p> 
        The system logging capabilities in BeOS are built on top of the syslog 
        interface as defined by the POSIX standard. In addition to the functionality 
        provided by that standard, it has some BeOS specific extensions. 
        </p> 
        <p> 
        The following article will give an overview about how this service works 
        internally in OpenBeOS, and how it can be used in applications. The implementation 
        as done in OpenBeOS might differ from the actual implementation in BeOS, but it 
        is fully binary compatible. 
        </p> 
        
        <h3>The syslog_daemon</h3> 

        <p> 
        The syslog service is provided by a standard <code>BApplication</code> that runs as a server in 
        the background, the syslog_daemon. 
        </p> 
        <p> 
        After it has been started during the system&#039s boot process, it will just sit 
        there and wait for messages. Every call to syslog() or log_thread/team() will 
        pass a message to the server containing information about what should be 
        written to the log and with what options. The message is not a <code>BMessage</code>, but 
        a plain data structure that can be created without any knowledge about <code>BMessage</code>s. 
        That is needed, because the service is used by the kernel as well. 
        </p> 
        <p> 
        The server then just passes on that message to its internal handlers. It has 
        two built-in handlers. One of them just processes the message and dumps a formatted 
        text to the syslog file at <i>/var/log/syslog</i>. The other one creates 
        a standard <code>BMessage</code> out of the message and broadcasts it to all of its listeners. 
        However, how you can communicate with the syslog_daemon to get those messages will 
        be the topic of another newsletter article. 
        </p> 
        <p> 
        If the syslog file reaches a certain size (512 kB), it will be renamed to <i>syslog.old</i>, 
        and a new syslog file is created. 
        </p> 

        <h3>Using the system logger</h3> 

        <p> 
        As already mentioned, the system logging capabilities are accessible via the standard 
        POSIX functions. Therefore, the <i>syslog.h</i> header is placed in the <i>headers/posix</i> 
        directory, and the functions are implemented in <i>libroot.so</i>. That&#039s already 
        different from standard BeOS where you need to link against <i>libbe.so</i> to access 
        that functionality. The <i>syslog.h</i> header can be found in the <i>headers/be/support</i> 
        directory on a standard BeOS system. 
        <br> 
        The implementation and header have been moved to simplify porting of POSIX-compliant 
        applications; however, that neither breaks binary nor source compatibility (as long as you 
        haven&#039t used "<code>#include &lt;support/syslog.h&gt;</code>" for your native Be apps.) 
        </p> 
        
        <h4>Logging sessions</h4> 

        <p> 
        The first call of a function that will connect to the syslog service will create a 
        syslog session. It&#039s important to know that there is one session for each thread 
        that uses the service, as well as one extra session for all team-wide logging 
        functions. 
        </p> 
        <p> 
        The original POSIX API as well as part of the additional BeOS API 
        both use thread specific sessions.  When a session is started, it will inherit the options 
        defined for the team session. That means you can set logging options that every 
        thread in your application will respect (if you don&#039t overwrite them locally). 
        But in order to define team wide options, you have to specifically use the BeOS-specific 
        team API. 
        </p> 
        
        <h4>Team functions</h4> 

        <ul> 
                <li><code>void openlog_team(const char *ident, int logopt, int facility)</code> 
                        <p> 
                        Sets the team logging options for the other team functions and for 
                        inherited sessions. 
                        <ul> 
                                <li><b>ident</b> is the identification string that prepends every message from your team.</li> 
                                <li><b>logopt</b> allows you to set several logging options (see below).</li> 
                                <li><b>facility</b> determines from what facility your message has been sent; for your 
                                        standard issues, this should just be LOG_USER.</li> 
                        </ul> 
                        </p></li> 
                <li><code>void closelog_team(void)</code> 
                        <p> 
                        Closes the current session. This has currently no effect for the team logging functions. 
                        </p> 
                <li><code>void log_team(int priority, const char *message, ...)</code> 
                        <p> 
                        Sends a message of the specified priority to the syslog daemon. 
                        </p> 
                <li><code>int setlogmask_team(int priorityMask)</code> 
                        <p> 
                        Use the LOG_MASK() macro to build a mask of priorities to show. All 
                        messages of other priorities will be discarded. Example uses: 
                        </p> 
                        <table border=0><tr><td width=50>&nbsp;</td> 
                                <td colspan=2><code>setlogmask_team(LOG_MASK(LOG_WARNING));</code></td></tr> 
                                <tr><td></td><td width=50></td> 
                                <td><i>// all messages of priority LOG_WARNING will be shown</i></td></tr> 
                        </table> 
                        <table border=0><tr><td width=50>&nbsp;</td> 
                                <td colspan=2><code>setlogmask_team(LOG_MASK(LOG_ERR + 1) - 1);</code></td></tr> 
                                <tr><td></td><td width=50></td> 
                                <td><i>// all messages with a priority level higher than LOG_ERR will be shown</i></td></tr> 
                        </table> 
                        </li> 
        </ul> 

        <h4>Thread functions</h4> 
        
        The POSIX API and the thread specific Be API behave exactly in the same way; 
        the <code>*_thread()</code> functions just clobber the global namespace :). 
        All calls except for the <code>closelog()</code> calls will start a new session 
        if there is none yet, and will inherit the current team logging options if they do. 

        <ul> 
                <li><code>void openlog_thread(const char *ident, int logopt, int facility)<br> 
                        void openlog(const char *ident, int logopt, int facility)</code> 
                        <p> 
                        Sets the log options for the current thread. 
                        </p> 
                <li><code>void closelog_thread(void)<br> 
                        void closelog(void)</code> 
                        <p> 
                        Closes the thread session, and frees all associated data. The next 
                        call to the syslog service will start a new session, and will inherit 
                        the team log options at that point again. 
                        </p> 
                <li><code>void log_thread(int priority, const char *message, ...)<br> 
                        syslog(int priority, const char *message, ...)</code> 
                        <p> 
                        Sends a message of the specified priority to the syslog daemon. 
                        </p> 
                <li><code>int setlogmask_thread(int priorityMask)<br> 
                        setlogmask(int priorityMask)</code> 
                        <p> 
                        Use the LOG_MASK() macro to build a mask of priorities to show. All 
                        messages of other priorities will be discarded. 
                        </p></li> 
        </ul> 

        <h4>Logging options for openlog()</h4> 

        These are the options that can be passed to openlog()/openlog_thread()/openlog_team(). 
        Note, its effects might be depending on the syslog listener; for example, for a GUI 
        syslog viewer, <b>LOG_PID</b> might have no effect at all. 

        <ul> 
                <li><b>LOG_PID</b><br> 
                        log the process (thread/team) ID with each message</li> 
                <li><b>LOG_CONS</b><br> 
                        if the message cannot be delivered to the syslog daemon, it will be 
                        directly dumped to stderr.</li> 
                <li><b>LOG_PERROR</b> 
                        the message will not only be sent to the syslog daemon, it will also 
                        be written to the application&#039s stderr, not only if sending fails like 
                        <b>LOG_CONS</b>.</li> 
        </ul> 

        There are some more flags defined, but they have currently no effect (notably, 
        <b>LOG_ODELAY</b>, <b>LOG_NDELAY</b>, <b>LOG_NOWAIT</b> and <b>LOG_SERIAL</b>). 

        <h3>Playing with the OpenBeOS implementation</h3> 

        <p> 
        The server is implemented in <i>current/src/servers/syslog_daemon</i>, naturally, 
        you have to build and start it, before it&#039ll work - although you can also check 
        out the syslog functionality without a living server. 
        </p> 
        <p> 
        To test the syslog functionality, you can use the provided test program. You&#039ll 
        find it in <i>current/src/tests/kernel/libroot/posix/SyslogTest.cpp</i>. Edit 
        it as you please, and you&#039ll get a good idea of how it works. 
        </p> 

        <h3>Differences between the OpenBeOS and the BeOS implementations</h3> 

        <p> 
        As already written some paragraphs above, the implemenation has been moved from 
        <i>libbe.so</i> to <i>libroot.so</i>. But since all applications are linked against 
        <i>libroot.so</i> anyway, this won&#039t have any impact on binary compatibility. 
        </p> 
        <p> 
        The header file <i>syslog.h</i> has been moved to the <i>headers/posix</i> directory, 
        where all other POSIX headers reside. If you&#039ve previously used the full path of 
        the old header ("<code>#include &lt;support/syslog.h&gt;</code>"), you might encounter 
        errors when trying to compile your old code. The issue has not been finally decided on, 
        but it probably won&#039t change in the release version of our headers. 
        </p> 
        <p> 
        It has not been tested if the thread logging functions inherit their settings from 
        the team session on R5 or not, and if this mechanism works similarly if it&#039s in place. 
        </p> 
        <p> 
        The only other known difference is that our syslog_daemon implements a way to broadcast 
        the messages to a listener application. But as I already said earlier, this will be the 
        topic of another newsletter article. Also note that the actual implementation of that 
        protocol has not been finalized yet and is probably subject to change; your shiny system 
        logger viewer might need to be updated before we reach R1. 
        </p> 

        <h3>References</h3> 

        <p> 
        There is a brief introduction to the BeOS system logger at 
        <a href="http://www.beatjapan.org/mirror/www.be.com/aboutbe/benewsletter/Issue61.html">http://www.beatjapan.org/mirror/www.be.com/aboutbe/benewsletter/Issue61.html 
</a>. 
        You can also find a description of the standard POSIX syslog functions at 
        <a href="http://www.opengroup.org/onlinepubs/007904975/functions/closelog.html">http://www.opengroup.org/onlinepubs/007904975/functions/closelog.html 
</a>. 
        </p> 
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:179) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="179">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">The &quot;virtualdrive&quot; driver</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:axeld@users.sourceforge.net">Axel D&ouml;rfler </a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                                 <p> 
        When developing an operating system, there is a big amount of secondary 
        tools and test applications involved. Sometimes, you will find surprisingly 
        useful things in this "cruft". 
        </p> 
        <p> 
        I want to introduce you to one of these gems today, the <i>virtualdrive</i> driver. 
        You can find it in <i>current/src/tests/kits/storage/virtualdrive</i> in our 
        repository. It has been developed mainly by Marcus Overhagen and Ingo Weinhold. 
        I only made some minor changes to make it more useful and dangerous for developing 
        the boot loader code. 
        </p> 
        <p> 
        It&#039s probably only useful for some of you, and therefore we haven&#039t yet put the 
        work into it and published it separately from our project. Also, it won&#039t be 
        needed in OpenBeOS anymore, anyway. 
        </p> 

        <h3>So, what does it good for me?</h3> 

        <p> 
        The driver only does one little thing: it allows device-like access to a file. 
        The main reason it has been developed was to test our partition scanner. You 
        can use complete hard drive images with that driver. 
        </p> 
        <p> 
        If you are using <i>Bochs</i> (there are several entries in BeBits, the most recent one 
        of them is (currently) <a href="http://www.bebits.com/app/3324">http://www.bebits.com/app/3324</a>) 
        to run other operating systems (or OpenBeOS), you will notice that it is not able 
        to access your devices directly, but needs every hard disk as a file. 
        </p> 
        <p> 
        With this driver and its accompanied <i>mkvirtualdrive</i> application, you can 
        make the partitions on these files directly accessible to BeOS, and just mount 
        them. 
        </p> 

        <h3>Installation</h3> 
        
        <p> 
        To install the driver to your local hard drive, you have to build it like this: 
        </p> 
        <pre> 
        $ jam install_virtualdrive 
        $ rescan virtualdrive 
        </pre> 
        <p> 
        To build the <i>mkvirtualdrive</i> tool, just type <code>jam</code> and then 
        move the executable (somewhere below the <i>distro</i>-tree; <i>jam</i> will print 
        out its exact location) to a place where you find it again, most probably you 
        want to put it somewhere in your path, too, so <i>/boot/home/config/bin</i> is 
        most appropriate for it. 
        </p> 
        <p> 
        For your convenience, I built a package that contains the driver and its controlling 
        application--<a href="http://www.openbeos.org/files/virtualdrive.zip">download it 
        from our server</a>. 
        </p> 

        <h3>How can I use it?</h3> 

        <p> 
        To avoid unwanted interactions with Tracker and other BeOS applications, the 
        driver publishes its devices under <i>/dev/misc/virtualdrive/</i>. That makes 
        its usage a bit more complicated than you&#039d want for the general end-user application. 
        </p> 
        <p> 
        Anyway, here is a step-by-step description of how to get it to work: 
        </p> 
        <pre> 
        $ mkvirtualdrive --install myHD.image 
        </pre> 
        <p> 
        This will print out the device under which you can now access the file. Note, the 
        file is no longer accessible directly. If you are issuing the above command for 
        the first time, you will probably get <i>"/dev/misc/virtualdrive/0"</i> back. 
        </p> 
        <p> 
        The file is now accessible through the device, but the BeOS disk system still 
        doesn&#039t take notice. If you want to mount the partitions on that image, or even 
        want to create new partitions on that image, format it with another file system 
        or whatever, you need to "connect" it to the system; you need to make a new "raw" 
        entry somewhere below <i>/dev/disk/</i>.  I choose the <i>/dev/disk/virtual/files</i> 
        directory for that. 
        </p> 
        <pre> 
        $ mkdir -p /dev/disk/virtual/files/0 
        $ ln -s /dev/misc/virtualdrive/0 /dev/disk/virtual/files/0/raw 
        </pre> 
        <p> 
        Now, <i>DriveSetup</i> will suddenly notice the new "disk," and the shell command 
        <i>mountvolume</i> will work on it as well. Unfortunately, Tracker will ignore the 
        new disk in its mount menu, but it will show the partition&#039s contents once you&#039ve 
        mounted them; partitions on that disk will have a blue cabinet icon in Tracker (if 
        they don&#039t have their own icon). 
        </p> 
        <p> 
        If you have a volume called "BeOS" on a partition on that disk, you can mount it 
        like this: 
        </p> 
        <pre> 
        $ mountvolume BeOS 
        </pre> 
        <p> 
        You can use the "-l" option to print out all mountable partitions; the partitions 
        on the new disk are visible there as well. 
        </p> 

        <h3>Advanced features</h3> 

        <p> 
        That&#039s nice, right? But as mentioned already, the file cannot be accessed anymore--the 
         driver locks the file for exclusive access. If you want to use the file in Bochs 
        again (or have a look at its contents with DiskProbe when you are developing a new 
        partitioning system add-on), you need to unregister the file with the driver again. 
        </p> 
        <p> 
        Normally, you would just use 
        <pre> 
        $ mkvirtualvolume --uninstall /dev/misc/virtualdrive/0 
        </pre> 
        to achieve that. But unfortunately, once you&#039ve introduced the device to the BeOS 
        disk system (by making the symlink and using <i>mountvolume</i> or <i>DriveSetup</i> on it), 
        it won&#039t close the device anymore, and therefore, the driver won&#039t let other people 
        access the file. 
        </p> 
        <p> 
        Note that you must unmount all mounted partitions from that file before you are 
        doing the next step! You can tell the virtualdrive driver to close the file for 
        some time and reestablish the connection later on. All accesses through the device 
        will fail, so you should not use <i>DriveSetup</i> or <i>mountvolume</i> during that 
        time: 
        </p> 
        <pre> 
        $ mkvirtualvolume --halt /dev/misc/virtualdrive/0 
        </pre> 
        <p> 
        The driver will close the file internally and allows others to access the file again. 
        If you want to activate the device again (i.e. to mount it again), you just need to 
        install it again like you did before: 
        </p> 
        <pre> 
        $ mkvirtualdrive --install myHD.image 
        </pre> 
        <p> 
        If nobody has closed the device in between and you haven&#039t used the driver for other 
        files in between, the file will be accessible through the device again. In order to 
        let it work, you have to provide the exact same image with the exact same path to 
        the "--install" call. 
        </p> 
        <p> 
        If you have forgotten which device points to what file, and which ones have been 
        disabled and which haven&#039t, you can use the following option of <i>mkvirtualdrive</i> 
        to get that info: 
        </p> 
        <pre> 
        $ mkvirtualdrive --info /dev/misc/virtualdrive/0 
        </pre> 

        <h3>Disclaimer</h3> 

        <p> 
        Before you are using this driver in the way explained here, especially when you are 
        using the features described under "Advanced features", you should make sure that you 
        won&#039t lose any important data on a sudden death. 
        </p> 
        <p> 
        We take no responsibility or liability on the effects of this software to your system. 
        However, if you are careful and respect the warnings and directions given in this 
        document, no case of failure or data loss is known to us. In any case, you&#039ve been 
        warned. :-) 
        </p> 
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:180) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="180">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Total User Experience</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:michaelphipps@users.sourceforge.net">Michael Phipps</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>My first conception of BeOS was probably a little different than that of most 
of you. When I first learned about BeOS, the BeBox had just premiered. I 
learned about BeOS from the BeBook on-line. This harkens back to the Old Days 
of computer science, when you wrote your program on paper, tested it by hand 
(desk checking) until you were sure that it was right, then submitted it to 
the computer for a batch job. Because I was not in a rush to find the 
object/method that I needed, I could instead focus on just enjoying the 
beauty of the design. It was a very pleasant experience.</p> 

<p>While I still like the API very much, it is not what most people see when 
they use an operating system. Most people&#039s perspectives on an operating 
system come from a very few components--installation, booting, the 
"desktop", and the applications. I believe that the philosophy that Be had 
for each piece of the operating system was something that they called "the 
Right Way." I call it TUE--Total User Experience. Why the change in 
nomenclature? I believe that it is very easy for engineers, sometimes, to 
forget who our "real" customers are. </p> 

<p>I suppose, then, that I should define who our "customers" are. There are many 
people who would like a piece of our efforts. I have heard from people who 
want to make OBOS the next server OS. Other people have said that it should 
be a great embedded OS. Yet others think that a platform for massive 
scientific computing makes sense. My consistent answer is that we should be 
the "Desktop OS." Some argue that we should stick with one of the last 
focuses of Be, Inc. and be the "Media OS." I am not opposed to being the 
"Media OS"; in fact, I believe that the two go hand in hand. Media, meaning 
video and sound, is inherent in the desktop. Ever since the multimedia hype of 
the mid-1990&#039s when x86 users found themselves capable of handling CD-quality sound 
and TV-quality graphics. Who would run a desktop OS that doesn&#039t play movies? 
Or one where they couldn&#039t play MP3&#039s (like I am right now)? No one. Media is a 
subset of desktop. Desktop is, of course, different from server, embedded (to 
some degree), and other platforms.</p> 

<p>With our "customers" thus defined let&#039s take a "TUE", then look at each of 
the most visible parts of BeOS and talk a bit about what was done right and 
wrong. </p> 

<p>Jean-Louis Gassee once said that Be looked at the price/performance curve and 
chose the "sweet spot". This was in regard, if I remember correctly, to 
choosing dual PPC 603s for the BeBox. What does it mean? There is frequently 
a trade off between two aspects of an engineering decision; usually if you 
plot them on a graph, it is exponential--the graph transitions from 
incremental increases in price providing massive performance to massive 
increases in price providing incremental performance. Processors still do this 
today. I believe that this particular philosophy is very much the embodiment 
of TUE. With nearly every place you can point out something bad about an operating 
system, it will be because a poor point on the graph is chosen. Windows takes 
forever to install and boot? Look and see how many devices are supported. If 
we support 1/10 of the devices, we can boot 25X faster, or something on that 
order. Choosing the right devices is the tricky part. That is the mastery of 
TUE--that it works exceptionally well for 90% of users and can be made to 
work with little effort for the other 10%. It is possible to build a system 
that works faster/better (think custom kernel builds with all hardware 
support compiled in) or one the supports more users (think Windows), but the 
sweet spot is somewhere in between. </p> 

<p>TUE is about making the user&#039s experience so great that they beg for more, 
not mercy. TUE is about building something that you are proud of and proud to 
be associated with, not something that has to hide behind press releases and 
excuses. TUE is about choosing what to do, then doing it the way that is the 
best trade off you can make. TUE is about cautious experimentation. Never just 
dump radical changes on the consumer without massive in-house and beta 
testing. Look at the trouble that Apple has had with users adopting OS X 
(and, for that matter, Microsoft with WinXP). On the contrary, Microsoft is 
not making a peep over the "leaked" screenshots from Longhorn. They have 
hundreds of real life criticisms years before it ships. </p> 

<p>The BeOS install is nearly optimal, as far as I can see. You can choose which 
partition you want and click Begin. That is the some total of the information 
that it needs to decide to install. No time zones, nothing else. The "More 
Options", which allows you to set up disk partitions is likewise very well 
done. There are a few changes that could be made in the partition tool, 
though. Specifically, it doesn&#039t tell you the hard disk name. You only find 
out the BeOS /dev path (marginally useful) and the total disk size. I know 
that the BIOS, at the very least, knows more than that. If the BIOS can know 
the disk manufacturer, we should be able to find it. Secondly, a minor nit, 
the grid control doesn&#039t have resizable columns. Finally, obviously unusable 
choices (floppy and CD-ROM) are listed. Still, all in all, this is the best 
installer that I have ever seen. </p> 

<p>Booting is another excellent experience within BeOS. The speed is still 
legendary and unmatched. Speed, while a component of TUE, is not the most 
important part. The boot loader is graphically helpful, showing what hardware 
that it has finished initializing, where in the boot process it is and giving 
you useful feedback instead of just a progress bar. Additionally, you can hit 
space bar and get all sorts of options for booting. Finally, and probably 
best of all, the system matches all of your hardware every time at runtime. 
That means that if you pull a HD out to boot somewhere else, it will *just 
work* assuming that you have drivers. </p> 

<p>Tracker, in many ways, is not much different than other desktop environments. 
The power of attributes and their flexible use is well-documented elsewhere. 
Replicants are different than the system tray that Windows offers. But, 
really, Tracker is very much like "everyone else"--there are icons on the 
desktop, folders can open, etc. Deskbar is not drastically better than the Start 
Menu from Windows. The desktop is an area where I have seen many complaints 
about the paradigm but few realistic choices.</p> 

<p>Finally, we have applications. BeOS offers many standard controls and a 
standard look. This is somewhat different from the *NIXes. Windows and MacOS 
have a definite edge here in terms of numbers and types of controls. I would 
like to address this in the future (R2 or beyond), as I believe that some of 
these would be very useful to OBOS application designers.</p> 

<p>BeOS, while not perfect, works very hard to do the things that it does "the 
Right Way". That is the tradition that we hope to carry on.</p> 
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
               	</font>
               	<tr><td><img src="images/spacer.gif" width=1 height=20></td></tr>
          	</table>
                                        </font>
                                   </td>
                                   <!-- / Content -->
                                   
                                   <td width=20 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=20>&nbsp;</td>
                                   <td width=1 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   
                                   
                                   
                                   <td width=10 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>

                              </tr>
                              <tr><td colspan=9 height=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td></tr>
                         </table>
                         <!-- / Main Table -->
                         


                    </body>
                    <!-- / Body -->
                    </html>