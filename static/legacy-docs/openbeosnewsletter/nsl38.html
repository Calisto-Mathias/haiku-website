
               <html>
                    <!-- Heading -->
                    <head>
                         <title>OpenBeOS Project - Displaying Newsletter</title>
                         <meta name="Keywords" content="OpenBeOS, BeOS, OBOS, operating system, developer">
                         <meta http-equiv="Cache-Control" content="no-cache">
                         <meta http-equiv="Pragma" content="no-cache">
                    </head>
                    <!-- / Heading -->
                    <!-- Body -->
                    <body bgcolor="#ffffff" leftmargin=5 topmargin=5>

                         <!-- Top Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0 bgcolor="#a7afbb">

                              <!-- Logo -->
                              <tr valign="bottom"><td><img src="images/logo.png" border=0></td></tr>
                              <!-- / Logo -->

                              <!-- Slogan -->
                              <tr valign="top">
                                   <td width="100%">
                                        <img src="images/spacer.gif" height=1 width=160><img src="images/slogan.png">
                                   </td>
                              </tr>
                              <!-- / Slogan -->

                              <tr><td colspan=2><img src="images/spacer.gif" height=6 width=1></td></tr>
                         
                         </table>
                         <!-- / Top Table -->
                         
                         <!-- Main Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0>
                              <tr valign="top">
                              
                                                  

                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>
                                   <td width=16 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=15>&nbsp;</td>
                                   
                                   <!-- Content -->
                                   <td width="100%">
                                        <font size="-1" face="Verdana, Arial">
                                        
     	    	<table width="99%" cellspacing=0 cellpadding=0 border=0>
           	     <tr>
                	     <td height="12"><a name="top">&nbsp;</a><img src="images/spacer.gif" heigh="12" width=1></td>
               	</tr>
               	<tr>
                         <td>
                    	     <img src="images/N.png" align="absmiddle" border=0>
                              <img src="images/spacer.gif" height=1 width=20>
                              <font face="Verdana, Arial" size="+2" color="#331111">Displaying Newsletter<div align="right"><font size="-1"><a href="index.html">Newsletter Archive</a></font></div></font>
                              <img src="images/spacer.gif" heigh=20 width=1>
                         </td>
               	</tr>
               	<font size="-1" face="Verdana, Arial">
               	
               <tr>
                    <td><font color="#113355" face="Verdana,Arial"><b>Issue 38, 19 Mar 2003</b></font>
                         
                    </td>
               </tr>
               <tr><td height="6"><img src="images/spacer.gif" height="6"></td></tr>
               <!-- Newsletter Header Links -->
               <tr>
                    <td bgcolor=#eeeeee>
                    
                         <table width="100%" cellspacing="2" cellpadding="0" border="0">
                              <tr valign="top">
                                   <td bgcolor="#f6f6f6">
                                        <font face="verdana,arial" size="-1">
                                        <br><br>&nbsp;&nbsp;<b><font color="">In This Issue:</font></b>
                                        <ul type="square">
                                             <li><a href="#137">template &lt madness &gt : Unit Test Policy </a>&nbsp; by Erik Jaesler</li><li><a href="#138">Can I Take a Message?</a>&nbsp; by DarkWyrm </li><li><a href="#139">The Palm Paradigm</a>&nbsp; by Michael Phipps</li>
                                        </ul>
                                        </font>
                                   </td>
                              </tr>
                         </table>
               
                    </td>
               </tr>
               <!-- / Newsletter Header Links -->
               
		     <!-- Newsletter Article (ID:137) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="137">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">template &lt madness &gt : Unit Test Policy </font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:erik@cgsoftware.com ">Erik Jaesler</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>Almost all of my recent coding efforts have gone into work on <code>BMessage</code>.  Early on, I decided that wanted to try a more "modern" back-end to 
<code>BMessage</code>, something that would leverage the power of the STL.  The end result is out there enough that I&#039m not sure I want to use it.  At any rate, I&#039m not going to talk about that right now; maybe in another article, if you&#039re all good. ;)
</p> 

<p>The OpenBeOS project has a pretty serious policy concerning unit testing, and <code>BMessage</code> is no different.  <code>BMessage
</code> has a great many convenience functions for directly adding/finding/replacing data for common types.  While it could be argued that all of these functions are similar enough that writing tests for one set would be good enough, 
<b>real</b> programmers won&#039t settle for anything less than complete coverage. =)  For those of you who aren&#039t actually writing code for OpenBeOS and haven&#039t ever written unit tests, let me assure you that they are often mind-numbingly tedious to code.  Now imagine the fun that lay in store for me as I write the same group of tests for each and every set of convenience functions:  there are, so far, 8 tests for the various convenience functions, each of which needs to be implemented for 
<code>bool, int8, int16, int32, int64, float, double, char*, BString, BPoint, BRect, entry_ref, BMessage, BMessenger</code>, raw pointer and 
<code>BFlattenable</code>.  Do the math and I&#039ve got 128 functions to implement.  "What about copy-&#039n&#039-paste and search-&#039n&#039-replace?" you ask.  For 120 functions??  I&#039d rather be gummed to death by a mob of toothless grandmothers!
</p> 

<p>My first idea was to procrastinate (during which time Nathan Whitehorn&#039s Resourcer app got a lot of attention from me).  My second idea was more productive:  I thought I would write a light-weight scripting engine to generate the source for me.  That actually made OK progress up to a point, but it felt clunky and it became clear that the engine would be difficult to extend.  As it turns out, the third time was a charm, but before I get into that, a little background.  On and off through 2002, I read a book called "Modern C++ Design: Generic Programming and Design Patterns Applied" by Andrei Alexandrescu.  If, like me, you happen to think that C++ templates are the greatest thing since iced water or just plain want to melt large portions of your cortex, this book is the 
<b>bomb</b>.  The things that Mr. Alexandrescu does with templates is absolutely sick -- and eminently useful, if you are writing libraries.  As it turns out, one of the techniques he discusses actually managed to lodge itself in my brain:  policy-based class design.  And now the fun begins.
</p> 

<p>The basic concept of policy-based class design is that certain bits of functionality in a class are grouped together into their own interface--the policy--which then becomes a template parameter for the class itself.  Here&#039s an example:  let&#039s suppose that you&#039re writing a library of classes and you want to make the method of memory allocation for the library customizable.  You could specify some base class which the user would then derive from to create his custom allocator.  The problem with this approach becomes apparent in that you want your allocator class to handle different types (after all, this library contains 
<b>classes</b> in the plural); something which is difficult to express through inheritance alone.  The alternate approach is to make your allocator class templatized on the type it&#039s going to allocate.  Lifted straight from "Modern C++ Design" are two examples:
</p> 

<pre>template <class T> struct OpNewCreator { 
        static T* Create() { 
                return new T; 
        } 
};</pre> 

<pre>template <class T> struct MallocCreator { 
        static T* Create() { 
                void* buf = std::malloc(sizeof(T)); 
                if (!buf) return 0; 
                return new(buf) T; 
        } 
};</pre> 

<p>The second allocator, MallocCreator, ensures that T can be a type with a constructor by using placement new on the malloc&#039d buffer.  Now the issue becomes one of getting your library classes to use these allocators -- after all, they&#039re not inherited from some base class, so you can&#039t just go passing base pointers around.  Again, templates ride to the rescue (also from "Modern C++ Design"):
</p> 

<pre>template <class CreatePolicy> 
class WidgetManager : public CreationPolicy { 
        ... 
};</pre> 

<p>Now if you want to use OpNewCreator for your allocation you simply do this:</p> 

<pre>typedef WidgetManager< OpNewCreator<Widget> > MyWidgetMgr;</pre> 

<p>If you want to use malloc, just do the same, substituting MallocCreator instead.  This concept works because the host class (<code>WidgetManager
</code> in this case) relies not on the policy class&#039s type, but on its interface--<code>static T* Create()</code>.</p> 

<p>As I was getting my scripting engine to the point where it was <b>almost</b> generating tests for <code>BMessage</code>&#039s <code>BRect
</code> convenience functions correctly ("Just a few more hours of ruthless hacking!"), it occurred to me that I was looking at a series of policies:
</p> 

<ul><li>the set of convenience functions getting tested (add/find/replace, etc.) 
<li>the initialization of variables (and arrays of variables) 
<li>the assertion of results in the tests 
</ul> 

<p>Thrown on top of those policies were two other vital pieces of information:  the type we were testing for (e.g., <code>int32</code>) and it&#039s type_code (e.g., 
<code>B_INT32_TYPE</code>).  Taken all together, we end up with a class declaration like this:</p> 

<pre>template 
< 
        class Type, 
        type_code TypeCode, 
        class FuncPolicy, 
        class InitPolicy, 
        class AssertPolicy 
> 
class TMessageItemTest { 
  public: 
        void MessageItemTest1(); 
        ... 
        void MessageItemTest8(); 
};</pre> 

<p>The tests are a bit big to list one here in its entirety, but they look something like the following:</p> 

<pre>void MessageItemTest1() { 
        BMessage msg; 
        Type out = InitPolicy::Zero(); 
        assert(FuncPolicy::Find(msg, "item", 0, &out) == B_NAME_NOT_FOUND); 
        assert(out == AssertPolicy::Invalid()); 
}</pre> 

<p>As I said, this isn&#039t a full test, but it should give you an idea of how the policies are getting used.  Just for clarity&#039s sake, here&#039s the same code, but written for a specific type (
<code>int32</code>):</p> 

<pre>void MessageItemTest1() { 
        BMessage msg; 
        int32 out = 0; 
        assert(msg.Find("item", 0, &out) == B_NAME_NOT_FOUND); 
        assert(out == 0); 
}</pre> 

<p>An interesting thing to note here is that for <code>int32</code>, <code>InitPolicy::Zero()</code> and <code>AssertPolicy::Zero()
</code> boil down to the same value:  zero.  Why not use one or the other in both places?  As it turns out, for other types, "zero" and "invalid" are not the same thing.  For instance, a "zero" 
<code>BRect</code> has left, top, right and bottom all set to 0.  However, an <b>invalid</b> <code>BRect</code> has left and top set to 0 and right and bottom set to -1.  You might begin to see why scripting could have a hard time cutting the mustard.
</p> 

<p>As it turns out, for most types <code>FuncPolicy</code> is conceptually identical:  call the type&#039s convenience function, passing in a name and value or index.  In fact, they&#039re so identical that we can create a policy-based class for that as well!  Here&#039s an abbreviated version:
</p> 

<pre>template 
< 
        typename Type, 
        status_t (BMessage::*AddFunc)(const char*, Type), 
        ... 
> 
struct TMessageItemFuncPolicy { 
        static status_t Add(BMessage& msg, const char* name, Type& val) { 
                return (msg.*AddFunc)(name, val); 
        } 
        ... 
}</pre> 

<p>It you&#039ve been considering what the fully fleshed out code for all this looks like, you&#039re probably thinking "This is getting pretty out of hand" by now, and if I had to do this more than once, I would absolutely agree.  The beautiful thing, though, is that I only have to write the test code 
<b>once</b>.  After that, I can specify a full set of tests for a given type with just this much code:</p> 

<pre>typedef TMessageItemFuncPolicy 
< 
        int32, 
        &BMessage::AddInt32, 
        &BMessage::FindInt32, 
        &BMessage::FindInt32,   <i>// The version that returns int32 directly</i> 
        &BMessage::HasInt32, 
        &BMessage::ReplaceInt32 
> 
TInt32FuncPolicy; 

struct TInt32InitPolicy { 
        inline static int32 Zero()      { return 0; } 
        inline static int32 Test1()     { return 1234; } 
        inline static int32 Test2()     { return 5678; } 
}; 

struct TInt32AssertPolicy { 
        inline static int32 Zero()              { return 0; } 
        inline static int32 Invalid()   { return 0; } 
}; 

typedef TMessageItemTest 
< 
        int32, 
        B_INT32_TYPE, 
        TInt32FuncPolicy, 
        TInt32InitPolicy, 
        TInt32AssertPolicy 
> 
TMessageInt32ItemTest;</pre> 

<p>There!  In a little over 30 lines of code, I&#039ve just created nearly 400 lines of tests!  Once that was done, it took less than half an hour to create the tests for about half of the types with 
<code>BMessage</code> convenience functions.  The key to all this is that you&#039re letting the compiler generate all the test code for you.

</p> 

<p>As I said before, I left a bit out, so if you have a burning curiosity (or twisted perversion, depending on your perspective) to know more, I encourage you to check out the various MessageXXXItemTest.h files in current/src/tests/kits/app/bmessage.  If that doesn&#039t cook your noodle, you just might be the very kind of sick monkey that would love "Modern C++ Design".  If so, you definitely owe it to yourself to read it.
</p> 

<p>You know, I just noticed I haven&#039t created the tests for floats or doubles yet--I think I&#039ll spend the next 10 minutes banging out 800 lines worth of code!
</p>
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:138) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="138">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Can I Take a Message?</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:bpmagic@columbus.rr.com">DarkWyrm </a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>One of the most interesting (and crucial) parts of BeOS aside from how blazingly fast it is would be the way an application communicate with its internals and with other applications. BMessages are flexible - usable for both a dessert topping and a floor wax. I&#039m still working on figuring out how to use them to make french fries, but I digress. Let us take a look at the big picture in how to communicate in BeOS.
</p> 
<h3>Being Deported</h3> 


<p>BeOS messaging builds on a foundation laid by the kernel. From the BeBook:</p> 

<p>A port is a system-wide message repository into which any thread can copy a buffer of data, and from which any thread can then retrieve the buffer. This repository is implemented as a first-in/first-out message queue: A port stores its messages in the order in which they&#039re received, and it relinquishes them in the order in which they&#039re stored. Each port has its own message queue. 
</p> 

<p>They can be used in C or C++ code, so it is theoretically possible to design and implement a completely different messaging system for BeOS - the kernel provides most of the heavy lifting and actual delivery. In fact, BeOS and OpenBeOS have done this to send low-overhead messages to and from the 
<code>app_server</code>, although in slightly different ways.</p> 
<p>At the most basic level, all that is needed to send a message is knowing the target port and calling the function write_port in some way like this:
</p> 

<pre>write_port( int32_message_code, pointer_to_associated_data );</pre> 

<p> Voila - it has been placed in a message queue for that port, awaiting the recipient to read the port, pick up the message, and have its way with what we sent.
</p> 


<h3>"You Can&#039t Handle the Truth!"</h3> 
<p>Well, maybe not, but BeOS messaging has a base class which can: BHandler. BHandler&#039s main task is to receive a message and decide what course of action to take next based on the message - calling a function, sending a reply, or whatever. It does this via the virtual function MessageReceived. By itself, a BHandler can&#039t do much, which leads to another important foundational class: BLooper.
</p> 

<p>BLoopers are a special kind of BHandler which monitors a port associated with it in a big loop - they pretty much wait for a message at the port, pick it up, and place it in a queue. Each message in the queue is taken in the order received. The Looper checks to see if a target was specified, and if not, passes it around to a list of message handlers. If not handled by any in the list, the Looper checks with its preferred message handler, and then finally handles the message itself. 
</p> 

<p>Neither of these sound particularly exciting on their own. However, when one considers that BViews are subclasses of BHandler and BWindows and BApplications are BLooper subclasses, suddenly the whole picture of BeOS Messaging becomes a little clearer. Windows and Applications talk to each other via a convenient, elegant abstraction over what the kernel provides.
</p> 

<p>BMessages are converted to a flat stream of bytes in order to be sent to a BLooper&#039s port via write_port(). The Looper unflattens the BMessage before placing it in a BMessageQueue object. This is done because a port has a limited capacity and a BMessageQueue does not. BMessages also contain useful identifying information, such as the ID of the BHandler who is the intended recipient if the sender specifies one and some useful data to allow the recipient to send a reply if it wishes to.
</p> 


<h3>Other Cool Stuff</h3> 

<p>As the announcer says in TV commercials, "But wait, there&#039s more!" Most of the time, one wishes to send a message to a window or the global application object from within an application. This merely requires having a pointer to the recipient object. What about a recipient in another application? That is why there are BMessengers. They can send a BMessage anywhere, if given an application signature, a looper, or a handler. Quite useful for interapplication communications. BInvokers are designed to be, well, invoked. They send a copy of a message to a specified target and are commonly used as a mix-in class for controls, such as buttons and such. BMessageRunners act as an interface to the system roster to send a message to a specific target via a BMessenger after a certain interval of time, possibly for a specified number of times. BMessageFilters can effectively allow a BLooper to say "I&#039m not listening! I can&#039t hear you! LA LA LA LA LA!", ignoring certain messages.
</p> 

<p>Certain classes probably won&#039t be used except in certain specialized cases. Others are used literally all the time. Now that you understand the big BeOS messaging picture, go write the next killer app and communicate better at the same time.
</p> 
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:139) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="139">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">The Palm Paradigm</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:michaelphipps@users.sourceforge.net">Michael Phipps</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <p>I recently bought a Palm III XE on EBay (where yesterday&#039s technology goes to be recycled). I didn&#039t buy it to use as a PDA; my life is not so complicated that I need a calendar, to do list, or address book. I do, however, read a lot, on the order of 1000 pages a week. My paper habit was getting to be very expensive. I have long been aware of Project Gutenburg, but sitting in front of my monitor to read is not what I would hold up as a great example. Running this huge, fast machine to be a text reader is pretty silly. And the 19" monitor is overkill, when I would be perfectly happy with a 4X6 sized book. Not to mention the lack of portability. So I bought the Palm to read e-texts on. 
</p> 

<p>In the process of getting acquainted with it, though, I have had a slow realization of why people love these things. It reminds me of the Walkman - it doesn&#039t do much, but what it does, it executes perfectly. Let&#039s start with the size - very comfortable and fits nicely in your hand. The square shape is a bit of a put-off, but the new Palms are nicely rounded. The reset button is easy to find but is impossible to press accidentally - nice thinking. It is a sturdy device - important for something designed to go into your pocket. The hardware isn&#039t the real jewel here, though. The software is extremely well executed. 
</p> 

<p>The introduction of Charles on the TV show M*A*S*H had a very memorable line - "I do one thing at a time, I do it very well, and I move on." In a way, the same thing could be said about Palm OS. I haven&#039t looked at the API, but from the end user&#039s point of view, it seems very obvious to me how to use it. As soon as I turned it on, there were icons on the desktop. Pretty familiar. But the desktop is not the "catch all" desktop that we use on our PCs. It is a display of applications. The applications are named by what they do, not cool in-jokes, programmers&#039 initials or funny acronyms. "Mail" is better than "Outlook", in my book. Every application runs in "full screen" mode. This seems to go back 20 years to the days of DOS but it works really well on the small screen. Furthermore, when you do switch applications, the old one continues to exist in just the state that you left it. It is similar to a persistent object paradigm. Applications are small, simple, and to the point. There aren&#039t so many features that you have to "learn" the program, but there are enough that I haven&#039t yet wondered if the application could be made tremendously more useful with just one more bell or whistle.
</p> 

<p>Graffiti is a pretty decent handwriting recognition system. While it does take a little training, it isn&#039t an onerous task in exchange for the ability to quickly and easily enter text. It does not make for a great Rogue-playing experience, though.
</p> 

<p>How does all of this relate to OBOS, aside from the irony of me buying from the company that bought Be? Just some thoughts about possible future directions. We aren&#039t making a PDA, nor should we try. But I do wonder if a micro-Tracker that works a lot like PalmOS would be good for newbies. All of the apps on the desktop would be clearly laid out and would start on single click. There would be no windows, but whole screen apps. Apps would never really close down, but would hide instead. File requestors would display any and all files that they can load, but nothing more or less. Syncing with another machine (file server? laptop? backup?) would be a trivial exercise. The applications would be so easy to use that a new person could learn the whole system in an hour or less. Installation of an app would be as easy as downloading a file. No need to select where the app goes or what disk it goes on - it would just work. 
</p> 

<p>Maybe even moving some of this point of view into "normal" OBOS would be a good idea. Do you really care how your hard drive is laid out? Do you really care that /boot/apps is where applications go? Or would an interface that takes care of all of that for you be "OK"? Would an interface that allows you to query for files more naturally than by directory name be good enough? Dealing with an interface like this would, to some degree, be about taking away power from the user. But if you don&#039t want or need that power, does it matter? 
</p> 
                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
               	</font>
               	<tr><td><img src="images/spacer.gif" width=1 height=20></td></tr>
          	</table>
                                        </font>
                                   </td>
                                   <!-- / Content -->
                                   
                                   <td width=20 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=20>&nbsp;</td>
                                   <td width=1 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   
                                   
                                   
                                   <td width=10 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>

                              </tr>
                              <tr><td colspan=9 height=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td></tr>
                         </table>
                         <!-- / Main Table -->
                         


                    </body>
                    <!-- / Body -->
                    </html>