
               <html>
                    <!-- Heading -->
                    <head>
                         <title>OpenBeOS Project - Displaying Newsletter</title>
                         <meta name="Keywords" content="OpenBeOS, BeOS, OBOS, operating system, developer">
                         <meta http-equiv="Cache-Control" content="no-cache">
                         <meta http-equiv="Pragma" content="no-cache">
                    </head>
                    <!-- / Heading -->
                    <!-- Body -->
                    <body bgcolor="#ffffff" leftmargin=5 topmargin=5>

                         <!-- Top Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0 bgcolor="#a7afbb">

                              <!-- Logo -->
                              <tr valign="bottom"><td><img src="images/logo.png" border=0></td></tr>
                              <!-- / Logo -->

                              <!-- Slogan -->
                              <tr valign="top">
                                   <td width="100%">
                                        <img src="images/spacer.gif" height=1 width=160><img src="images/slogan.png">
                                   </td>
                              </tr>
                              <!-- / Slogan -->

                              <tr><td colspan=2><img src="images/spacer.gif" height=6 width=1></td></tr>
                         
                         </table>
                         <!-- / Top Table -->
                         
                         <!-- Main Table -->
                         <table width="100%" cellspacing=0 cellpadding=0 border=0>
                              <tr valign="top">
                              
                                                  

                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>
                                   <td width=16 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=15>&nbsp;</td>
                                   
                                   <!-- Content -->
                                   <td width="100%">
                                        <font size="-1" face="Verdana, Arial">
                                        
     	    	<table width="99%" cellspacing=0 cellpadding=0 border=0>
           	     <tr>
                	     <td height="12"><a name="top">&nbsp;</a><img src="images/spacer.gif" heigh="12" width=1></td>
               	</tr>
               	<tr>
                         <td>
                    	     <img src="images/N.png" align="absmiddle" border=0>
                              <img src="images/spacer.gif" height=1 width=20>
                              <font face="Verdana, Arial" size="+2" color="#331111">Displaying Newsletter<div align="right"><font size="-1"><a href="index.html">Newsletter Archive</a></font></div></font>
                              <img src="images/spacer.gif" heigh=20 width=1>
                         </td>
               	</tr>
               	<font size="-1" face="Verdana, Arial">
               	
               <tr>
                    <td><font color="#113355" face="Verdana,Arial"><b>Issue 15, 06 Apr 2002</b></font>
                         
                    </td>
               </tr>
               <tr><td height="6"><img src="images/spacer.gif" height="6"></td></tr>
               <!-- Newsletter Header Links -->
               <tr>
                    <td bgcolor=#eeeeee>
                    
                         <table width="100%" cellspacing="2" cellpadding="0" border="0">
                              <tr valign="top">
                                   <td bgcolor="#f6f6f6">
                                        <font face="verdana,arial" size="-1">
                                        <br><br>&nbsp;&nbsp;<b><font color="">In This Issue:</font></b>
                                        <ul type="square">
                                             <li><a href="#46">A Tale of Two Net Stacks</a>&nbsp; by David Reid</li><li><a href="#48">Hardware OpenGL and where it should take us</a>&nbsp; by Michael Phipps</li><li><a href="#47">Unit Testing</a>&nbsp; by Jeremy Rand</li>
                                        </ul>
                                        </font>
                                   </td>
                              </tr>
                         </table>
               
                    </td>
               </tr>
               <!-- / Newsletter Header Links -->
               
		     <!-- Newsletter Article (ID:46) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="46">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">A Tale of Two Net Stacks</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:dreid@users.sf.net">David Reid</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         Michael Phipps keeps referring to all the progress we're making on the networking team,
but unless you're subscribed to our <a href="http://www.freelists.org/archives/openbeosnetteam/" target="_blank">mailing list</a>,
you may not really be aware of how much we've done.
Hopefully this article will explain further what we're doing and why we've made the decisions we've made
and taken the paths we've taken. If you're looking for an article with lots of technical information, this won't be it!
Maybe I'll write one of those next?
<p><br>
<b>The Beginning</b>
<p>
In the beginning... Ah, it seems like such a long time ago! The generally held logic is that the networking belongs in the kernel.
This has proven to be the best place for it on many systems and provides for the best performance.
It does, however, add significant overhead to the project, as developing in kernel land is anything but straightforward on
an open system with the kernel source available, so the prospect of doing it on a closed system against a kernel we didn't know
everything about...
<p>
When we started looking at actually adding code, we had a debate about the correct path to take.
It was decided that going for a userland stack would be the easiest and, if we were careful,
it could be moved into the kernel at a suitable point.
<p>
Why is a userland stack easier to write? In some ways it's not. The network protocols are the same, the way the data within them
has to be manipulated is the same. Where it does gain a huge advantage, especially when you're just starting, is the ability
to debug using familiar tools and in a nice "safe" environment that doesn't lead to rebooting when the code crashes.
When the stack crashes (and crash it did in those early days) the system didn't crash and it was possible to carry on working.
This is something I would only dream about later in the development.
<p>
Development went quite quickly and some of my early ideas went out the window as I realised they just couldn't be done.
However, the server slowly started taking shape and the data began to flow from and to the network!
The various milestones were rewarding to reach. The first time the server read data from the network and the first time it
replied to a ping request stand out as being memorable.
<p><br>
<b>The Middle</b>
<p>
There was one issue that had been in the back of my mind since the start that I still didn't have a solution for.
As we started adding things like sockets and the ability to bind and send/receive data from them, this issue started growing,
and the more we looked at it, the messier and more problematic it became.
<p>
What was the issue? Put simply, it was how do we communicate with the network stack?
If the stack was running in one team, and we're in another team, how do we talk to it?
Can't do it directly as the memory spaces are "ring fenced" to a team.
So, do we use shared areas of memory and use semaphores to inform the various parties there's data there?
Maybe we use BMessages with a suitable C interface? You see the problem.
<p>
What we're talking about is designing and writing an IPC, Inter Process Communication, mechanism that would be at the heart
of our net stack. This filled me with fear as it was about as far away from the KISS principle as I think we can get.
The performance of this layer would be crucial to the whole server and we'd be writing it from the ground up.
No, this wasn't a good idea.
<p><br>
<b>Unexpected Turns</b>
<p>
Then along came Philippe Houdoin. Philippe has more background in drivers and kernel modules than most of us in the group,
and he came up with a way to have a driver register with the select() hook (not used presently) and then have the operating system
actually use it! Bruno and the BFS guys added support very quickly and it became obvious Philippe had been right.
This discovery got me thinking, and reopened the debate about how we do things within the networking team.
<p>Philippe went even further and contributed some code that essentially created a socket device that could be used to create/use
sockets using the standard system calls. Suddenly things were looking <b>very</b> different.
<p>
I had a few days away from the computer, due to work obligations, and started thinking that this might be just what was required
to move the code into the kernel, thereby removing the IPC issue altogether. In fact, the more I thought about it,
the more certain I became that this was the way to go. When I got home, I started looking at code and experimenting with some ideas.
It wasn't long before I had enough working to be able to commit code to our current tree.
<p>
It took me a while to get it working, and I was a constant visitor to Kernel Debugger Land (KDL).
Eventually things started to come together, and I had code that would react to network packets, running inside the kernel.
The next step was simple -- write a socket driver that we could use to communicate with the stack! Oh yes, such a simple exercise!
Well, in fact, using the code from Philippe as a base, it turned out be relatively simple. In about an hour, I had a simple driver
that could actually open a socket in the stack!
<p><br>
<b>The Home Stretch</b>
<p>
Next was to make a library that knew how to talk to the socket driver in a sensible fashion. This had been discussed on the list,
and the general consensus was to call it libnet.so. The Be version had all sorts of functionality that traditional unix systems
have in their libc (Be's libroot), so these are being moved and added to our libnet as well. Already we have various
inet_ functions available. Writing the library took about 30 minutes and then compiling and linking a small test app against it
about another 20 minutes. Suddenly it all worked! Yes, the test app opened a socket in the new net stack and then closed it again.
Not much maybe, but a huge step forward in terms of proving our approach.
<p>
Over the last couple of days [<em>editor's note: this article was originally submitted 2 weeks ago</em>], I've added support
for the functions we had prior to our move to kernel land. Along the way, I've expanded the configuration support and built
an ifconfig application that can set the ip address for an interface and show details of the devices configured.
<p>
At present libnet.so can do the following...
<ul type=square>
<li>socket()
<li>closesocket()
<li>bind()
<li>sendto()
<li>recvfrom()
</ul>
<p>
Support is also written and just needs testing for:
<ul type=square>
<li>listen()
<li>connect()
</ul>
<p><br>
<b>Where next?</b>
<p>
Well, the path has been long, and has taken more twists than I care to remember.
The result? Well, today we have a set of code that builds as either a kernel network stack or as a userland application.
The userland application isn't really usable for much beyond basic testing, as tests need to be written into the application itself,
but it is still proving to be invaluable in debugging new code.
<p>
I'd like to say that I'm 100% sure what will be done next, but I'm not.
There are a lot of things that need to be fixed and even more things that need to be added. Among the highlights of things
that need to be done before long are:
<ul type=square>
<li>routing sockets
<li>ip fragmentation
<li>ip options
<li>icmp error function
<li>netstat application
</ul>
<p>
Well, hopefully that makes things somewhat clearer and gives you an idea of how we're getting on.
Keep watching this space.

                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:48) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="48">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Hardware OpenGL and where it should take us</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:michaelphipps@users.sf.net">Michael Phipps</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         I want to talk a little bit (and I do mean a little) about the issues around even doing a HWOGL (Hardware OpenGL) implementation.
Then I want to talk a little bit about my vision about where things should go and why.
<p>
Prepare yourself for an earthshaking statement: A quality implementation of hardware accelerated 3D graphics is hard.
Be labored away at it for over a year, with staffing that was quite good (some of whom I knew personally).
You see, video card companies are always tweaking their drivers to squeeze more speed out.
There are tons of issues an implementor has to deal with:
<ul type=square>
<li>taking advantage of everything that every card maker offers
<li>making up for, in software, what each card maker *doesn't* offer
<li>being fast
<li>looking good
<li>not slagging the system
</ul>
<p>
I like playing games.
HW accelerated OpenGL is important to me. I was crestfallen, the other day, when I saw that Neverwinter Nights will not be coming out for BeOS.
I can't fault the publisher, since no one could use it legally, but I still don't like it. I *want* BeOS to be a great gaming platform. 
<p>
So, you are asking yourself, why is he talking about gaming, what does this have to do with 3D GUIs, and, well,
why doesn't he just go and do something about it?
<p>
All good questions. Gaming is the most frequent and most well understood usage of 3D graphics.
Many of the people in the GlassElevator list, recently, described various input methods for 3D in terms of games that they had played.
All well and good. 3D games (and 3D guis) are exceptionally unrealistic without hardware acceleration.
As for doing something about it, well, there are several issues. 
<p>
First off, engineers aren't lego blocks -- you can't just arrange them any way that you want. :-)
Secondly, no one has come on board and said "I know *a lot* about 3D and I want to do this".
Third, it is out of scope for R1, since R5 didn't have it. 
<p>
OK. So we know why we don't have HWOGL and aren't likely to any time soon. It is on the radar, just a long way off.
The next question is, what should we do with it once we have it? There are many levels of use we could put it to. 
<p>
One is, simply enough, to replicate a 2D gui with it. Use it for z buffering. Easy to understand, fairly easy to write, low risk.
Also pretty boring. A second (if you will) level of implementation that I think would be neat is to replace "fake3D" with real 3D. 
<p>
For example -- windows over and under each other is a 3D concept that is "faked out" in 2D. With real 3D, one could do perspective,
for example. Another instance of fake3D is buttons. We use drop shadowing to simulate "pressing" a button.
A very good optimization technique. For 1985. How about real 3D buttons. For instance, when you press them, they "dimple" in
the exact spot that you press them while you press them, giving the impression that you left a little mark and that
the button is made of a pliable material.
<p>
Another example -- the scroll wheel could be zoom in and out,
for example, giving you the ability to move closer (even, maybe, through a document, to what is underneath, then back out).
This is real power for the user: instead of bringing a window to the foreground, you could just zoom in toward it, then back out.
Pretty cool! The user would be able to control zoom on documents. Instead of every document having a drop down with percentages of magnification,
zoom in and out is built in. Everything would have to be vectors (i.e. not bitmaps) for this to work without being horribly ugly,
but that is not too much of a stretch, either.
<p>
People often speak of how cool it would be to extend the metaphor of the desktop (and real life) to 3D and have you literally
pick up a document and carry it from one place to another. I don't really follow that line of reasoning. We invented computers
and their modern uses because the way that people were doing things was inefficient.
Why would we want to continue that inefficent way of working? Computers are a different medium to work in than "real life".
3D can be used to emulate real life. But is that the Right Thing to do?

                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
		     <!-- Newsletter Article (ID:47) -->
               <tr>
                    <td height="30"><img src="images/spacer.gif" height="30" width="1"></td>
               </tr>
               <tr>
                    <td>
                         <a name="47">&nbsp;<br></a>
                         
                         <table width="100%" cellspacing="0" cellpadding="0" border="0">
                              <tr><td bgcolor="#999999" colspan="2" height="2"><img src="images/spacer.gif" height="2"></td></tr>
                              <tr>
                                   <td height="32" width="80%">
                                        <b><font face="verdana,arial" color="#331111">Unit Testing</font></b>
                                   </td>
                                   <td align="right"><font size="-1">by <a href="mailto:jrand@users.sf.net">Jeremy Rand</a></font>&nbsp;</td>
                              </tr>
                              <tr><td bgcolor="#999999" colspan="2" height="3"><img src="images/spacer.gif" height="3"></td></tr>
                              <tr><td colspan="2" height="15"><img src="images/spacer.gif" height="15"></td></tr>
                         </table>
                         
                    </td>
               </tr>
               <tr>
                    <td>
                         <font size="-1" face="verdana,arial">
                         <P>Unit testing is the process of showing that a part of a software system works as far as the
requirements created for that part of the system.  Unit testing is best if it has the following
characteristics:</P>
<UL type=square>
<LI>The software component is tested in isolation with as little interaction with other software
components as possible.</LI>
<LI>The software component is tested using automated tools so that unit tests can be run with
every build of the software if required.</LI>
<LI>All requirements of the software component are tested as part of the unit tests.</LI>
</UL>
<P>Unit testing is not the only type of testing but is definitely a very important part of any
testing strategy.  Following unit testing, software should go through "integration testing" to
show that the components work as expected when put together.</P>
<P>This article describes the "why's" and "how's" of unit testing for the AppKit team of the
OpenBeOS project.  Although it is intended for the AppKit team, there is no reason other teams
couldn't use this information to develop a similar unit testing strategy.</P>
<p><br>
<b>Why is unit testing important?</b>
<P>A basic concept of software engineering is that the cost of fixing a bug goes up by a factor
of 2-10x (depending on the source of the information) the later in the development process it is
found.  Unit testing is critical to finding implementation bugs within a particular component as
quickly as possible.</P>
<P>Unit testing will also help to find requirements problems also.  If you write the requirements
(or use cases) for your component from the BeBook, hopefully the BeBook and your use cases will
match the actual Be implementation.  A good way to confirm that the BeBook documentation matches
Be's implementation is to write your unit tests and run them against the original Be code.</P>
<P>Unit tests will also continue to be maintained and run in the future also.  As the mailing 
lists obviously show, many people are looking forward to OpenBeOS post-R1 when new features
will be introduced above and beyond BeOS R5.  These unit tests will be critical to ensuring that
any new feature or even just a bug fix doesn't break existing functionality.</P>
<P>Speaking of bug fixes, consider adding unit tests for any bugs you identify that slipped
through your original unit test suite.  This will ensure that this bug or a similar one is not
re-introduced in the future.</P>
<P>Finally, unit testing is not the be all, end all of testing.  As mentioned above, integration
testing must be done to show that software components work together.  If all unit tests cover
all requirements and have run successfully against all components, then a failure has to be
due to a bug in the interaction of two or more known working software components.</P>
<p><br>
<b>When should I write my unit tests?</b>
<P>As the AppKit process document describes the recommended order for implementing a component
is:</P>
<OL>
<LI>Write an interface specification</LI>
<LI>Write the use case specifications</LI>
<LI>Write the unit tests</LI>
<LI>Write an implementation plan</LI>
<LI>Write the code</LI>
</OL>
<P>Please see the <a href="http://www.cgsoftware.com/erik/IKTeam/IK_Process.html" target="_blank">AppKit process document</a> for
more details about the entire sequence.  The unit tests are to be written once the use cases are written and before any
implementation work is done.  The use cases must be done because they determine what the tests will be.
You need to write as many tests are required so that all use cases for that component are tested.
The use cases should be detailed enough that you can write your unit tests from them.</P>
<P>The unit tests are to be done before implementation for a very good reason.  You should be able
to run these unit tests against the Be implementation and confirm that they all pass.  If they do
not pass, then either there is a bug in the unit test itself or you have found a difference
between your use cases and the actual implementation.  Even if your use cases match the BeBook,
if that is not how the actual Be implementation works, we must match the current implementation and
not the BeBook.  You should go back and modify the use case.  Change the use case so that it
matches Be's implementation and consider adding a note indicating this doesn't match the 
BeBook.</P>
<P>Imagine if you completed the implementation and then wrote and ran the unit tests.  If you run
the tests against your implementation and Be's implementation, you will notice the test passes
for your code but fails on Be's.  At this point, you will have to change the implementation, change
the unit test and change the use case which is more work that if you write the unit tests before
the implementation.  Worse, if you only ran the unit tests against your implementation and not
Be's, you may not notice the problem at all.</P>
<A NAME="whattests"></A>
<p><br>
<b>What kinds of tests should be in a unit test?</b>
<P>The unit tests you write should cover all the functionality of your software module.  That
means your unit tests should include:</P>
<UL type=square>
<LI>All standard expected functionality of the software component</LI>
<LI>All error conditions handled by the software component</LI>
<LI>Interaction with software components which cannot be decoupled from the target software 
component</LI>
<LI>Concurrency tests to show that a software component which is expected to be thread safe (most
things are under BeOS) is safe and free from deadlocks.</LI>
</UL>
<p><br>
<b>What framework is being used to do unit testing for the AppKit?</b>
<P>The AppKit team has chosen to use CppUnit version 1.5 as the basis of all of our unit tests.
This framework provides very useful features and ensures that all unit tests for AppKit code
are consistent and can be executed from a single environment.</P>
<P>There are two key components to the framework.  First, there is a library called libCppUnit.so
which provides all the C++ classes for defining your own testcases.  Secondly, there is an
executable called "TestRunner" which is capable of executing a set of testcases.</P>
<P>For more information on CppUnit, please refer to 
<A HREF="http://cppunit.sourceforge.net/">this website</A>
<p><br>
<b>What AppKit specific modifications have been made to this framework?</b>
<P>The following are the modifications that have been introduced into the CppUnit v1.5 
framework:</P>
<UL type=square>
<LI>A makefile has been added for the library and the TestRunner.</LI>
<LI>Some "bugs" in CppUnit v1.5 which lead to it not compiling under BeOS v5.</LI>
<LI>The TestRunner has been modified to support BeOS based addons.  Each test which you can
select from the TestRunner is found in the "add-ons" directory at runtime.  The original 
TestRunner required you to change the TestRunner when new tests were added to it.</LI>
<LI>Changed the output from TestRunner.  The output includes a name of the test being run and
a run time for the test in microseconds.</LI>
<LI>Changed the arguments of the assert functions in the TestCase class from std::string to
const char *'s due to apparent concurrency problems with std::string under BeOS when testing
threaded tests.</LI>
<LI>Added locking to the TestResults class so that multiple threads can safely add result 
information at the same time for a single test.</LI>
<LI>The ThreadedTestCaller class was written to allow us to write tests which contain multiple
threads.  This is an important class because many BeOS components are thread safe and we need
to confirm that the OpenBeOS implementation is also thread safe.</LI>
</UL>
<P>This is the list of the important modifications done to CppUnit v1.5 at the time this document
is being written.  For the latest information about modifications to CppUnit, check the code
which can be found in the OpenBeOS CVS repository.</P>
<p><br>
<b>What framework modifications might be required in the future?</b>
<P>This framework will have to evolve as our needs grow.  The main issues I think we need to
solve are:</P>
<UL type=square>
<LI>The format of the test name is an encoded string representing the class definition of the
test class from gcc.  It is not a very readable format but given that the test class is often
a template class and you would like different names for different instances of the template,
this seemed the best compromise.  Suggestions welcome.</LI>
<LI>The threaded test support added into CppUnit forces you to specify the entry point for each
thread in your test.  If you are doing a test with a BLooper or a BWindow, these classes start
a thread of their own.  This thread will not be started through the standard entry point so
doing "assert's" from one of these threads will not work.  Perhaps we need TestBLooper and
TestBWindow classes which will work with the assert's.</LI>
</UL>
<P>If you find you need some other features, feel free to add them to CppUnit.</P>
<A NAME="buildingtests"></A>
<p><br>
<b>How do I build the framework and current tests for the AppKit?</b>
<P>As of writing this document, you can build the framework and all the current AppKit tests
by performing the following steps:</P>
<OL>
<LI>Checkout the "app_kit" sources or the entire repository from the OpenBeOS CVS repository.
There is information at the OpenBeOS site about how to access the CVS repository.</LI>
<LI>In a terminal, "cd" into the "app_kit" directory in the CVS files you checked out.</LI>
<LI>Type "make".</LI>
</OL>
<P>Note that the build system for OpenBeOS is moving to jam so these steps may become obsolete.
When you the make has finished, you should find the following files:</P>
<UL type=square>
<LI><CODE>app_kit/test/CppUnit/TestRunner</CODE> - this is the executable to use to execute
tests.</LI>
<LI><CODE>app_kit/test/CppUnit/lib/libCppUnit.so</CODE> - this is CppUnit library which your tests
must link against.</LI>
<LI><CODE>app_kit/test/CppUnit/lib/libopenbeos.so</CODE> - this is library which contains OpenBeOS
implementation of some Be classes (usually found in libbe.so, called libopenbeos.so to avoid a name
clash at runtime).</LI>
<LI><CODE>app_kit/test/add-ons/BAutolockTests</CODE> - this is the addon which contains the tests
which are run against the Be and OpenBeOS implementation of BAutolock.</LI>
<LI><CODE>app_kit/test/add-ons/BLockerTests</CODE> - this is the addon which contains the tests
which are run against the Be and OpenBeOS implementation of BLocker.</LI>
<LI><CODE>app_kit/test/add-ons/BMessageQueueTests</CODE> - this is the addon which contains the tests
which are run against the Be and OpenBeOS implementation of BMessageQueue.</LI>
</UL>
<P>These are the key files which ensure that the tests can be run.</P>
<p><br>
<b>How do I run tests?</b>
<P>You have a few different options for how you run a test or a series of tests.  Before you start
however, you must build the code as describe <A HREF="#buildingtests">in this section</A>.  Once
it is built, you can run tests any of these ways:</P>
<UL type=square>
<LI>Run "make test" from the app_kit directory.  This will lead to all of the tests defined in
app_kit/test/add-ons directory to be run.</LI>
<LI>From the "app_kit/test" directory, execute the command "CppUnit/TestRunner -all".  This will
lead to all of the tests defined in the app_kit/test/add-ons directory to be run and is the same
as what happens in the "make" example above.  However, recompile any code that has changed in the
process.</LI>
<LI>From the "app_kit/test" directory, execute the command "CppUnit/TestRunner &lt;TestName&gt;"
where &lt;TestName&gt; is one of the addons found in the "app_kit/test/add-ons" directory.  Only
the tests defined in that add-on will be run.</LI>
</UL>
<p><br>
<b>How do I write tests for my component?</b>
<P>The first step to writing your tests is to develop a plan for how you will test the 
functionality.  For ideas of the kinds of tests you may want to consider, you should reference
<A HREF="#whattests">this section</A>.</P>
<P>Once you know the kinds of tests you want, you need to:</P>
<UL type=square>
<LI><P>For every test you want, define a class which derives from the "TestCase" class in the 
CppUnit framework.</P></LI>
<LI><P>Within each test class you define, create a "void setUp(void)" and "void tearDown(void)"
member function if required.  If before executing your test, you need to perform some actions,
put those actions in the "setUp()" member.  If you need to cleanup after your test, put those
actions in the "tearDown()" member.</P></LI>
<LI><P>Within each test class you define, create a member function which takes "void" and
returns "void".  Within this member function, write the code to execute the test.  Whenever you
want to ensure that some condition is true during your test, add a line within the member function
that looks like "assert(condition)".  For example, if the variable "result" must have the value
B_OK at a particular point in your test, you should add a line which reads
"assert(result = B_OK)".</P></LI>
<LI><P>Create a constructor for all of your test classes that takes a "std::string name" argument
and pass that onto the TestCase parent class.  Add whatever actions you need to take in the
constructor.</P></LI>
<LI><P>Create a destructor for all of your test classes and take whatever actions are 
appropriate.</P></LI>
<LI><P>Within each test class you define, create a member with the signature 
"static Test *suite(void)".  For a simple test where only one test needs to be run for this class,
the contents of this member should look like:</P>
<PRE>
return(new TestCaller&lt;ClassName&gt;("", &amp;ClassName::MemberName));
</PRE>
<P>Replace "ClassName" with the name of your test class and "MemberName" with the name
of the member function you defined your test in.  If you need to define more than one test to run
from this class, refer to instructions below on how to use the TestSuite class of CppUnit.  If you
are creating a threaded test, refer to <A HREF="#threadedtests">this section</A>.</P></LI>
<LI><P>Create one ".cpp" file for defining the "addonTestFunc()" function.  This function must
exist in global scope within your test addon.  The contents of this ".cpp" file will look something
like:</P>
<PRE>
#include "TestAddon.h"
Test *addonTestFunc(void)
{
    TestSuite *testSuite = new TestSuite("&lt;TestSuiteName&gt;");
    testSuite-&gt;addTest(&lt;ClassName1&gt;::suite());
    testSuite-&gt;addTest(&lt;ClassName2&gt;::suite());
    /* etc */
    return(testSuite);
}
</PRE>
<P>In the above example, replace &lt;TestSuiteName&gt; with an appropriate name for the group of
tests and &lt;ClassName1&gt; and &lt;ClassName2&gt; with the names of the test classes you have
defined.</P></LI>
<LI><P>Create a build system around a BeIDE project, Makefile or preferrably a jam file which
builds all the necessary code you have written into an addon.</P></LI>
<LI><P>Put this addon into the app_kit/test/add-ons directory and follow the above instructions
for how to run your tests.</P></LI>
</UL>
<p><br>
<b>Are there example tests to base mine on?</b>
<P>There are example tests which you can find in the following directories:</P>
<UL type=square>
<LI><CODE>app_kit/test/lib/application/BMessageQueue</CODE></LI>
<LI><CODE>app_kit/test/lib/support/BAutolock</CODE></LI>
<LI><CODE>app_kit/test/lib/support/BLocker</CODE></LI>
</UL>
<P>There are some things done in these tests which make things a bit more complex, but you may
want to do similar things:</P>
<UL type=square>
<LI>Most tests use a ThreadedTestCaller class even in some situations when there aren't actually
more than one thread in the test.</LI>
<LI>All tests are defined as a template class.  The test class is a template of the class to test
(if that makes sense to you).  For example, to test both the Be and OpenBeOS BLocker and not
end up with a symbol conflict, the OpenBeOS implementation of BLocker is actually in a namespace
called "OpenBeOS".  So, the tests must be run against the classes "::BLocker" and 
"OpenBeOS::BLocker".  The easiest way to do this was to make the class to be tested a template
and define it for both "::BLocker" and "OpenBeOS::BLocker".</LI>
</UL>
<P>Even with the complexity, I think this code provides a pretty good example of how to write
your tests.</P>
<A NAME="threadedtests"></A>
<p><br>
<b>How do I write a test with multiple threads?</b>
<P>If you have a test which you want to define that requires more than one thread of execution
(most likely a concurrency test of you code), you need to use the ThreadedTestCaller class.
The steps which differ from the above description on how to write a test case are:</P>
<UL type=square>
<LI><P>In your test class, define a member function for each thread you will be starting.  All of
these member functions must take "void" and return "void".  If all the threads in your test
perform the exact same actions, it is OK to just define one member function.  Usually in the
tests I have written, I have called these member functions "TestThread1()", "TestThread2()",
etc.</P></LI>
<LI><P>If your "static Test *suite()" function for your test class, you must return a
ThreadedTestCaller.  Imagine that the test class name is "MyTestClass" and you want two threads
which run member functions "TestThread1()" and "TestThread2()".  That code would look like:</P>
<PRE>
Test *MyTestClass::suite(void)
{
    MyTestClass *theTest = new MyTestClass("");
    ThreadedTestCaller&lt;MyTestClass&gt; *threadedTest =
        new TreadedTestCaller&lt;MyTestClass&gt;("", theTest);
    threadedTest-&gt;addThread(":Thread1", &amp;MyTestClass::TestThread1);
    threadedTest-&gt;addThread(":Thread2", &amp;MyTestClass::TestThread2);
    return(threadedTest);
}
</PRE>
<P>If you need to, you can put a number of ThreadedTestCaller instances into a TestSuite and return
them in the suite() member function.  Examples of this can be found in the BLocker and 
BMessageQueue test examples.</P></LI>
</UL>
<P>Otherwise the steps are the same as for other tests.  The code gets much more complex if you
define your test classes as templates as the examples do.</P>

                         </font>
                    </td>
               </tr>
               <!-- / Newsletter Article -->
               	</font>
               	<tr><td><img src="images/spacer.gif" width=1 height=20></td></tr>
          	</table>
                                        </font>
                                   </td>
                                   <!-- / Content -->
                                   
                                   <td width=20 bgcolor="#ffffff"><img src="images/spacer.gif" height=1 width=20>&nbsp;</td>
                                   <td width=1 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   
                                   
                                   
                                   <td width=10 bgcolor="#fcfcfc"><img src="images/spacer.gif" height=1 width=10>&nbsp;</td>
                                   <td width=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td>

                              </tr>
                              <tr><td colspan=9 height=1 bgcolor="#dddddd"><img src="images/spacer.gif" height=1 width=1></td></tr>
                         </table>
                         <!-- / Main Table -->
                         


                    </body>
                    <!-- / Body -->
                    </html>